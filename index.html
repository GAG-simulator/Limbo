<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LIMBO</title>
    <style>
        :root {
            --ui-bg: rgba(20, 20, 20, 0.85);
            --border-color: rgba(140, 140, 140, 0.6);
            --highlight-color: #fff;
            --un-craftable-color: #ff5555;
            --slot-bg: #2c2c2c;
            --slot-size: clamp(40px, 10vw, 60px);
            --ui-padding: clamp(10px, 3vw, 20px);
            --ui-radius: 8px;
        }
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            image-rendering: pixelated;
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 1.5s cubic-bezier(0.5, -0.5, 0.5, 1.5);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111;
            cursor: crosshair;
            transition: filter 1.5s linear;
        }

        /* --- UI Over Game --- */
        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: var(--ui-padding);
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
        }
        .game-ui-element {
            background-color: var(--ui-bg);
            backdrop-filter: blur(4px);
            border-radius: var(--ui-radius);
            border: 2px solid var(--border-color);
            padding: 8px 12px;
            box-sizing: border-box;
            pointer-events: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #health-bars-container {
            flex-grow: 1;
            max-width: 350px;
            padding: 8px;
        }
        #mental-health-bar-container {
           width: 100%;
           height: 16px;
           background-color: #444;
           border-radius: 4px;
           overflow: hidden;
           position: relative;
        }
        #mental-health-bar {
            width: 100%;
            height: 100%;
            background-color: var(--highlight-color);
            transition: width 0.2s;
            border-radius: 4px;
        }
        #shield-bar-container {
           display: none;
           width: 100%;
           height: 14px;
           background-color: #444;
           border-radius: 4px;
           margin-top: 6px;
           overflow: hidden;
        }
        #shield-bar {
            width: 100%;
            height: 100%;
            background-color: #00aaff;
            transition: width 0.2s;
            border-radius: 4px;
        }

        #clock-container {
            text-align: center;
            font-size: clamp(14px, 4vw, 18px);
            flex-shrink: 0;
            font-weight: bold;
        }
        #handbook-button {
             width: 42px;
             height: 42px;
             font-size: 24px;
             font-weight: bold;
             padding: 0;
             cursor: pointer;
             flex-shrink: 0;
             line-height: 38px;
             text-align: center;
        }
        #handbook-button:hover {
            border-color: #fff;
            background-color: #333;
        }

        #bottom-ui {
            position: absolute;
            bottom: var(--ui-padding);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 15px;
            pointer-events: none;
            z-index: 10;
        }
        #hotbar {
            display: flex;
            gap: 8px;
            background-color: var(--ui-bg);
            backdrop-filter: blur(4px);
            padding: 8px;
            border-radius: var(--ui-radius);
            border: 2px solid var(--border-color);
            pointer-events: auto;
        }
        .hotbar-slot {
            width: var(--slot-size);
            height: var(--slot-size);
            border: 2px solid var(--border-color);
            background-color: var(--slot-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            user-select: none;
            border-radius: 6px;
            transition: all 0.1s;
            cursor: pointer;
            overflow: hidden;
        }
        .hotbar-slot:hover {
            border-color: #aaa;
        }
        .hotbar-slot.selected {
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
            z-index: 2;
        }
        .item-icon {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            pointer-events: none;
        }
        .durability-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            width: 100%;
            background-color: #444;
        }
        .durability-bar-inner {
            height: 100%;
            transition: width 0.2s, background-color 0.2s;
        }
        .dragging {
            opacity: 0.5;
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        
        /* --- Screens --- */
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
        }
        .screen-overlay h1 { font-size: clamp(32px, 8vw, 64px); margin-bottom: 20px; color: #eee; text-shadow: 0 0 10px #000; }
        .screen-overlay p { max-width: 600px; line-height: 1.6; padding: 0 20px; font-size: clamp(14px, 4vw, 18px); color: #ccc; }
        .screen-overlay button {
            background: var(--slot-bg); color: #fff; border: 2px solid var(--border-color); padding: 15px 30px;
            font-family: inherit; font-size: clamp(16px, 5vw, 20px); cursor: pointer; margin-top: 15px; border-radius: var(--ui-radius);
            min-width: 250px;
            transition: all 0.2s;
        }
        .screen-overlay button:hover { border-color: var(--highlight-color); background-color: #444; transform: translateY(-2px); }
        .screen-overlay button:active { transform: translateY(0); }
        .screen-overlay button:disabled { background: #111; color: #555; border-color: #333; cursor: not-allowed; transform: none;}
        
        /* --- Character Select (FIXED) --- */
        #character-select-wrapper {
            position: relative;
            width: 100%;
            max-width: 900px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 60px; /* Make space for arrows */
            box-sizing: border-box;
        }
        #character-carousel {
            display: flex;
            align-items: center;
            gap: 20px;
            width: 100%;
            height: 320px;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            scrollbar-width: none;
            padding: 0 calc(50% - 110px); 
            box-sizing: border-box;
            scroll-behavior: smooth;
        }
        #character-carousel::-webkit-scrollbar { display: none; }
        
        .character-card {
            flex-shrink: 0;
            scroll-snap-align: center;
            width: 220px;
            height: 280px;
            background-color: #222;
            border: 3px solid var(--border-color);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 15px;
            box-sizing: border-box;
            gap: 15px;
            user-select: none;
            opacity: 0.5;
            transform: scale(0.9);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .character-card.selected {
            opacity: 1;
            transform: scale(1);
            border-color: var(--highlight-color);
            background-color: #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .character-card h3 { margin: 0; text-align: center; font-size: 20px; color: #fff; }
        .character-card .char-icon { width: 100px; height: 100px; display: flex; justify-content: center; align-items: center; }
        
        #character-details { min-height: 100px; max-width: 600px; margin-top: 20px; padding: 0 20px; }
        #character-details h2 { color: var(--highlight-color); margin-bottom: 10px; }
        
        .carousel-btn {
            background: rgba(0,0,0,0.7); color: #fff; border: 2px solid #555; font-size: 24px; cursor: pointer;
            padding: 0; border-radius: 50%; width: 50px; height: 50px; display: flex; justify-content: center; align-items: center;
            transition: all 0.2s; position: absolute; top: 50%; transform: translateY(-50%); z-index: 10;
        }
        .carousel-btn:hover { background: rgba(255,255,255,0.2); border-color: #fff; }
        #prev-char { left: 0px; }
        #next-char { right: 0px; }
        @media (max-width: 600px) { .carousel-btn { display: none; } }

        /* --- Inventory and Crafting --- */
        #inventory-screen, #chest-screen {
            flex-direction: row;
            flex-wrap: nowrap;
            gap: 20px;
            padding: var(--ui-padding);
            align-items: stretch;
            justify-content: center;
            z-index: 200;
        }
        .inventory-panel {
            background: rgba(30, 30, 30, 0.95);
            border: 2px solid var(--border-color);
            border-radius: var(--ui-radius);
            padding: 15px;
            max-height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            width: clamp(300px, 45vw, 450px);
            box-sizing: border-box;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        
        .inventory-panel h2 {
            margin-top: 0; text-align: center; border-bottom: 1px solid #444; padding-bottom: 10px; color: #ddd;
        }

        #recipe-list { 
            list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; 
            scrollbar-width: thin; scrollbar-color: #555 #222;
        }
        #recipe-list::-webkit-scrollbar { width: 8px; }
        #recipe-list::-webkit-scrollbar-track { background: #222; }
        #recipe-list::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        
        #recipe-list li {
            padding: 10px; border-bottom: 1px solid #333; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
        }
        #recipe-list li:hover { background-color: #383838; }
        #recipe-list li.selected { background-color: #444; border-left: 4px solid #fff; }
        #recipe-list li.un-craftable { color: #777; }

        #crafting-details ul li.needed-bad { color: var(--un-craftable-color); }
        
        #inventory-grid, #player-chest-grid, #chest-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(var(--slot-size), 1fr));
            gap: 8px;
            overflow-y: auto;
            flex-grow: 1;
            padding: 5px;
        }
        .inventory-slot.drop-slot {
            border: 2px dashed #ff5555;
            background-color: rgba(255, 85, 85, 0.05);
        }
        .drop-slot svg { width: 50%; height: 50%; fill: #ff6b6b; pointer-events: none; }
        
        @media (max-width: 800px) {
            #inventory-screen, #chest-screen { flex-direction: column; align-items: center; }
            .inventory-panel { width: 95vw; max-height: 45vh; }
        }
        
        /* --- Handbook --- */
        #handbook-panel {
            background: #222;
            border: 2px solid var(--border-color);
            border-radius: var(--ui-radius);
            width: clamp(300px, 90vw, 800px);
            height: clamp(400px, 80vh, 700px);
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        #handbook-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; padding-bottom: 15px; margin-bottom: 15px; }
        #handbook-tabs { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .handbook-tab {
            background: #333; padding: 8px 16px; border-radius: 4px; cursor: pointer; border: 1px solid transparent;
        }
        .handbook-tab.active { background-color: #555; border-color: #fff; }
        #handbook-content { overflow-y: auto; flex-grow: 1; }
        .handbook-entry { display: flex; align-items: center; gap: 20px; padding: 15px; border-bottom: 1px solid #333; }
        .handbook-entry-icon { width: 48px; height: 48px; flex-shrink: 0; }
        .handbook-entry-text h3 { margin: 0 0 5px 0; color: #fff; }
        .handbook-entry-text p { margin: 0; color: #aaa; font-size: 14px; }

        /* --- Controls --- */
        #joystick-container {
            position: absolute;
            bottom: calc(var(--ui-padding) + var(--slot-size) + 30px);
            left: var(--ui-padding);
            width: 120px; height: 120px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: none;
            z-index: 50;
            border: 2px solid rgba(255,255,255,0.1);
        }
        #joystick-handle {
            position: absolute; width: 50px; height: 50px;
            background-color: rgba(255, 255, 255, 0.3); border-radius: 50%;
            left: 35px; top: 35px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }

        .mobile-ui-button {
            width: var(--slot-size); height: var(--slot-size);
            border: 2px solid var(--border-color); background-color: var(--ui-bg);
            display: none; justify-content: center; align-items: center;
            border-radius: var(--ui-radius); pointer-events: auto; cursor: pointer;
        }
        .mobile-ui-button svg { width: 60%; height: 60%; fill: #fff; }
        
        #notification-container {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 8px; z-index: 250; pointer-events: none;
        }
        .notification-message {
            background-color: rgba(0,0,0,0.8); color: #fff; padding: 8px 16px;
            border-radius: 20px; border: 1px solid #555; font-size: 14px;
            animation: fadeOut 4s forwards;
        }
        @keyframes fadeOut { 0% { opacity: 0; transform: translateY(10px); } 10% { opacity: 1; transform: translateY(0); } 90% { opacity: 1; } 100% { opacity: 0; transform: translateY(-20px); } }

        #sleep-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #000;
            opacity: 0; pointer-events: none; z-index: 500; transition: opacity 1.5s ease-in-out;
        }
        
        .controls-hint {
            position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 12px; pointer-events: none;
            display: none;
        }
        @media (min-width: 1024px) { .controls-hint { display: block; } }
    </style>
</head>
<body>

    <div id="start-screen" class="screen-overlay">
        <h1>Limbo</h1>
        <p>Вы застряли между мирами. Выживайте, стройте, сохраняйте рассудок.</p>
        <p style="font-size: 14px; color: #888; margin-bottom: 20px;">ПК: WASD - движение, E - инвентарь<br>Зажать ЛКМ - ломать свои постройки<br>Зажать ПКМ - быстро ставить блоки<br>Моб: Джойстик + Тап</p>
        <button id="prequel-button">Предыстория</button>
        <button id="start-button">Новая игра</button>
        <button id="continue-button" style="display: none;">Продолжить</button>
    </div>
    
    <div id="character-select-screen" class="screen-overlay" style="display: none;">
        <h1>Выберите персонажа</h1>
        <div id="character-select-wrapper">
            <button id="prev-char" class="carousel-btn">&#10094;</button>
            <div id="character-carousel">
                <!-- Cards injected here -->
            </div>
            <button id="next-char" class="carousel-btn">&#10095;</button>
        </div>
        <div id="character-details">
            <h2 id="char-name"></h2>
            <p id="char-desc"></p>
        </div>
        <button id="confirm-char-button">Начать</button>
        <button id="back-to-main-menu-button" style="background: transparent; border: none; color: #888; margin-top: 5px;">Назад</button>
    </div>

    <div id="prequel-screen" class="screen-overlay" style="display: none;">
        <h1>Предыстория</h1>
        <p>ТЫ ЧЕЛОВЕК, КОТОРЫЙ НЕ ПОПАЛ НИ В РАЙ, НИ В АД И ОСТАЛСЯ В ЛИМБО СКИТАТЬСЯ ВЕЧНОСТЬ...</p>
        <button id="back-from-prequel-button">Назад</button>
    </div>

    <div id="game-over-screen" class="screen-overlay" style="display: none;">
        <h1 style="color: #ff5555">Рассудок потерян</h1>
        <p>Вы стали очередной тенью в этом месте.</p>
        <p id="days-survived-text" style="font-size: 1.2em; color: #fff;"></p>
        <button id="restart-button">Попробовать снова</button>
    </div>
    
    <div id="handbook-screen" class="screen-overlay" style="display: none; z-index: 300;">
        <div id="handbook-panel">
            <div id="handbook-header">
                <h1 style="font-size: 24px;">Справочник</h1>
                <button id="handbook-close-button" style="min-width: auto; padding: 5px 15px;">&times;</button>
            </div>
            <div id="handbook-tabs"></div>
            <div id="handbook-content"></div>
        </div>
    </div>

    <div id="inventory-screen" class="screen-overlay" style="display: none;">
        <div id="crafting-panel" class="inventory-panel">
            <h2>Крафт</h2>
            <ul id="recipe-list"></ul>
            <div id="crafting-details" style="padding: 10px; background: #222; margin-top: 10px; border-radius: 5px;">
                <p style="font-size: 14px; color: #777;">Выберите рецепт</p>
            </div>
            <button id="craft-button" disabled style="margin-top: auto;">Создать</button>
        </div>
        <div id="inventory-panel" class="inventory-panel">
            <h2>Инвентарь</h2>
            <div id="inventory-grid"></div>
        </div>
    </div>
    
    <div id="chest-screen" class="screen-overlay" style="display: none;">
        <div id="player-chest-panel" class="inventory-panel">
            <h2>Ваш Инвентарь</h2>
            <div id="player-chest-grid"></div>
        </div>
        <div id="chest-panel" class="inventory-panel">
            <h2>Сундук</h2>
            <div id="chest-grid"></div>
        </div>
    </div>
    
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="sleep-overlay"></div>
        <div id="notification-container"></div>
        <div id="top-bar">
            <div id="health-bars-container" class="game-ui-element">
                <div id="mental-health-bar-container">
                    <div id="mental-health-bar"></div>
                </div>
                <div id="shield-bar-container">
                    <div id="shield-bar"></div>
                </div>
            </div>
             <div style="display: flex; gap: 10px; align-items: center;">
                <div id="clock-container" class="game-ui-element">
                    <div id="day-counter">День 1</div>
                    <div id="time-display">06:00</div>
                </div>
                <button id="handbook-button" class="game-ui-element">?</button>
            </div>
        </div>
        <div id="bottom-ui">
            <div id="hotbar"></div>
            <div id="inventory-button-mobile" class="mobile-ui-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z"/></svg>
            </div>
        </div>
        <div id="joystick-container"></div>
        <div class="controls-hint">E - Инвентарь | Зажми ПКМ - стройка | Зажми ЛКМ - снос</div>
    </div>
    
    <script type="module">
        // --- Game Initialization ---
        const canvas = document.getElementById('game-canvas'); const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const startScreen = document.getElementById('start-screen'); const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button'); const restartButton = document.getElementById('restart-button');
        const inventoryScreen = document.getElementById('inventory-screen'); const joystickContainer = document.getElementById('joystick-container');
        const prequelScreen = document.getElementById('prequel-screen');
        const prequelButton = document.getElementById('prequel-button');
        const backFromPrequelButton = document.getElementById('back-from-prequel-button');
        const handbookScreen = document.getElementById('handbook-screen');
        const handbookButton = document.getElementById('handbook-button');
        const handbookCloseButton = document.getElementById('handbook-close-button');
        const chestScreen = document.getElementById('chest-screen');
        const characterSelectScreen = document.getElementById('character-select-screen');
        const confirmCharButton = document.getElementById('confirm-char-button');
        const backToMainMenuButton = document.getElementById('back-to-main-menu-button');

        let sleepOverlay;
        
        const SAVE_KEY = 'limbo_savegame_new_biomes_v1'; 
        
        const TILE_SIZE = 32, WORLD_WIDTH = 600, WORLD_HEIGHT = 600;
        const MENTAL_HEALTH_DRAIN_RATE = 0.5, ANGEL_HEAL_RADIUS = TILE_SIZE * 4, ANGEL_HEAL_RATE = 15, HUMAN_HEAL_RADIUS = TILE_SIZE * 3, HUMAN_HEAL_RATE = 5;
        const DAY_DURATION_SECONDS = 24 * 60; 
        const PLAYER_STUN_DURATION = 3; 
        const ANGEL_SHADOW_DAMAGE = 15;
        const CAMPFIRE_SHADOW_DAMAGE = 25;
        const BERRY_GROWTH_TIME = 120;
        const VOID_AURA_RADIUS = TILE_SIZE * 6;
        const VOID_AURA_DAMAGE = 20;

        const CAMPFIRE_FUEL_PER_WOOD = 300; 
        const MAX_CAMPFIRE_FUEL = CAMPFIRE_FUEL_PER_WOOD * 10;
        const CAMPFIRE_PLACEMENT_RANGE = TILE_SIZE * 10;
        const CAMPFIRE_HEAL_RATE = 3; 
        const CAMPFIRE_HEAL_RADIUS = TILE_SIZE * 3;
        const CAMPFIRE_LIGHT_RADIUS = TILE_SIZE * 5;
        const FLASHLIGHT_RANGE = TILE_SIZE * 8;
        const FLASHLIGHT_CONE_ANGLE = Math.PI / 4; 
        const FLASHLIGHT_DAMAGE = 10; 
        let ENTITY_DESPAWN_RADIUS;
        let lastJoystickAngle = 0;

        let player, world, entities, camera, joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0, magnitude: 0 };
        let placedObjects = []; 
        let growableObjects = [];
        let droppedItems = [];
        let traps = []; 
        let projectiles = []; 
        let mousePos = { x: 0, y: 0 };
        let isMouseDown = false; 
        let isRightMouseDown = false;
        let actionTimer = 0;
        let selectedHotbarSlot = 0, keys = {}, gameState = 'start', lastTime = 0, gameTime = DAY_DURATION_SECONDS * 0.25; 
        let autoSaveInterval;
        let activeChest = null;
        
        // --- Data Structures ---
        const ITEM_TYPES = {
            WOOD: { id: 'WOOD', name: 'Дерево' }, 
            STONE: { id: 'STONE', name: 'Камень' },
            AXE: { id: 'AXE', name: 'Топор', durability: 50 }, 
            PICKAXE: { id: 'PICKAXE', name: 'Кирка', durability: 50 }, 
            SWORD: { id: 'SWORD', name: 'Меч', durability: 75 },
            SICKLE: { id: 'SICKLE', name: 'Серп', durability: 75 },
            STONE_AXE: { id: 'STONE_AXE', name: 'Кам. топор', durability: 100 }, 
            STONE_PICKAXE: { id: 'STONE_PICKAXE', name: 'Кам. кирка', durability: 100 },
            STONE_SWORD: { id: 'STONE_SWORD', name: 'Кам. меч', durability: 150 },
            FIRE_AXE: { id: 'FIRE_AXE', name: 'Огненный топор', durability: 250 }, 
            FIRE_PICKAXE: { id: 'FIRE_PICKAXE', name: 'Огненная кирка', durability: 250 }, 
            FIRE_SWORD: { id: 'FIRE_SWORD', name: 'Огненный меч', durability: 300 },
            FIRE_SICKLE: { id: 'FIRE_SICKLE', name: 'Огненный серп', durability: 150 },
            DARK_ORB: { id: 'DARK_ORB', name: 'Шар Тьмы' }, 
            MENTAL_SALVE: { id: 'MENTAL_SALVE', name: 'Целебная мазь' },
            ACORN: { id: 'ACORN', name: 'Жёлудь' },
            SAKURA_PETAL: { id: 'SAKURA_PETAL', name: 'Лепесток сакуры' },
            DESPAIR_CRYSTAL: { id: 'DESPAIR_CRYSTAL', name: 'Кристалл отчаянья' },
            SLEEPING_BAG: { id: 'SLEEPING_BAG', name: 'Спальник' },
            CAMPFIRE: { id: 'CAMPFIRE', name: 'Костёр' },
            FLASHLIGHT: { id: 'FLASHLIGHT', name: 'Фонарик', durability: 500 },
            TECHNOLOGY_SHARD: { id: 'TECHNOLOGY_SHARD', name: 'Осколок Технологии' },
            ANCIENT_CIRCUIT: { id: 'ANCIENT_CIRCUIT', name: 'Древняя плата' },
            ASTRAL_ARTIFACT: { id: 'ASTRAL_ARTIFACT', name: 'Астральный артефакт' },
            LIGHT_ORB: { id: 'LIGHT_ORB', name: 'Орб Света' },
            DOOR: { id: 'DOOR', name: 'Дверь' },
            CHEST: { id: 'CHEST', name: 'Сундук' },
            MYSTERIOUS_ARTIFACT: { id: 'MYSTERIOUS_ARTIFACT', name: 'Загадочный артефакт'},
            BED: { id: 'BED', name: 'Кровать' },
            BERRY: { id: 'BERRY', name: 'Ягода' },
            WITHERED_GRASS: { id: 'WITHERED_GRASS', name: 'Сухая трава' }
        };
        const TILE_TYPES = { EMPTY: 0, TREE: 1, ROCK: 2, WOOD_BLOCK: 4, STONE_BLOCK: 5, BIRCH: 6, OAK: 7, SAKURA: 8, RUINS_WALL: 9, ARTIFACT_BOX: 10, BERRY_BUSH: 13, GRASS_TUFT: 14 };
        const ENTITY_TYPES = { 
            SHADOW: 'SHADOW', ANGEL: 'ANGEL', HUMAN: 'HUMAN', MUTANT_HUMAN: 'MUTANT_HUMAN', 
            ARCHANGEL: 'ARCHANGEL', DEMON: 'DEMON', FALSE_ANGEL: 'FALSE_ANGEL', VOID: 'VOID',
            STATUE: 'STATUE', MIMIC: 'MIMIC'
        };
        
        let selectedRecipe = null;
        
        const BIOME_SIZE = 40; 
        const BIOME_TYPES = { PLAINS: 0, FOREST: 1, BIRCH_FOREST: 2, OAK_FOREST: 3, SAKURA_GROVE: 4, MINE: 5, STRANGE_VALLEY: 6 };
        let biomeMap;

        // --- Graphics ---
        const art = {
            player: [['#ccc', '#ccc'],['#888', '#888'],['#888', '#888'],['#444', '#444']],
            player_sleeping: [['#d88', '#d88', '#c66', '#c66'], [null, '#ccc', '#ccc', null], [null, '#888', '#888', null]],
            human: [['#f0d2a4', '#f0d2a4'], ['#3e84d4', '#3e84d4'], ['#3e84d4', '#3e84d4'], ['#5a3d24', '#5a3d24']],
            tree: [[null, '#292', '#292', null],['#292', '#3a3', '#3a3', '#292'],[null, '#643', '#643', null],[null, '#643', '#643', null]],
            birch: [[null, '#ddd', '#111', null],['#ddd', '#fff', '#111', '#ddd'],[null, '#eee', '#eee', null],[null, '#eee', '#eee', null]],
            oak: [[null, '#282', '#282', null],['#282', '#3a3', '#3a3', '#282'],[null, '#754', '#754', null],[null, '#754', '#754', null]],
            sakura: [[null, '#fbc', '#fbc', null],['#fbc', '#fce', '#fce', '#fbc'],[null, '#532', '#532', null],[null, '#532', '#532', null]],
            rock: [[null, '#888', null],['#aaa', '#888', '#aaa'],['#aaa', '#aaa', '#aaa']],
            shadow: (f) => [[null, f ? '#222' : '#111', null],[f ? '#333' : '#222', '#111', f ? '#333' : '#222'],[null, f ? '#222' : '#111', null]],
            angel: (f) => [[f ? '#fff' : '#eee', '#fff', f ? '#fff' : '#eee'],[null, '#ddd', null]],
            axe: [['#ccc', '#aaa', null],[null, '#643', '#ccc'],[null, '#643', null]],
            pickaxe: [['#ccc', '#ccc', '#ccc'],[null, '#643', null],[null, '#643', null]],
            sword: [[null, '#fff', null],[null, '#fff', null],[null, '#643', null]],
            sickle: [['#888', '#666', null], [null, '#643', '#888'], [null, '#643', null], ['#643', null, null]],
            wood_block: [['#965', '#854', '#965', '#854'],['#643', '#854', '#643', '#854'],['#965', '#854', '#965', '#854'],['#643', '#854', '#643', '#854']],
            stone_block: [['#aaa', '#aaa', '#999', '#888'],['#aaa', '#888', '#888', '#999'],['#999', '#888', '#777', '#777'],['#888', '#999', '#777', '#aaa']],
            stone_axe: [['#888', '#666', null],[null, '#643', '#888'],[null, '#643', null]],
            stone_pickaxe: [['#888', '#888', '#888'],[null, '#643', null],[null, '#643', null]],
            stone_sword: [[null, '#888', null],[null, '#888', null],[null, '#643', null]],
            dark_orb: [[null, '#201', null], ['#302', '#101', '#302'], [null, '#201', null]],
            mental_salve: [[null, '#afa', null], ['#9c9', '#dfd', '#9c9'], [null, '#afa', null]],
            acorn: [[null, '#864', null],['#864', '#a85', '#864'],[null, '#a85', null]],
            sakura_petal: [[null, '#fde', null], ['#fde', '#fbc', '#fde']],
            despair_crystal: [[null, '#aaf', '#aaf', null], ['#aaf', '#fff', '#fff', '#aaf'], ['#aaf', '#fff', '#fff', '#aaf'], [null, '#aaf', '#aaf', null]],
            sleeping_bag: [[null, '#d88', '#d88', '#c66'], [null, '#d88', '#c66', '#c66'], ['#432', '#432', '#432', '#432']],
            campfire: [[null, '#f80', '#fc0', null], ['#f80', '#a00', '#f80', '#fc0'], ['#888', '#777', '#888', '#777']],
            flashlight: [[null, '#ddd', '#ddd'], ['#666', '#444', '#444'], ['#666', '#444', '#444'], [null, '#666', null]],
            mutant_human: [['#bda', '#bda', null, null],['#494', '#494', '#bda', '#bda'],['#494', '#494', '#f00', '#494'],['#bda', '#bda', '#494', '#494'],[null, null, '#864', '#864']],
            archangel: [['#ff0', '#ff0', '#ff0', '#ff0'],['#fff', '#ff0', '#ff0', '#fff'],[null, '#fff', '#fff', null],['#eee', '#eee', '#eee', '#eee'],['#eee', null, null, '#eee']],
            demon: [['#f00', null, null, '#f00'],['#400', '#f00', '#f00', '#400'],['#400', '#200', '#200', '#400'],[null, '#200', '#200', null],['#100', null, null, '#100']],
            false_angel: (f) => [[f ? '#ccc' : '#bbb', '#ccc', f ? '#ccc' : '#bbb'], [null, '#aaa', null]],
            fire_axe: [['#f80', '#f60', null],[null, '#643', '#f80'],[null, '#643', null],[null, '#643', null]],
            fire_pickaxe: [['#f80', '#f80', '#f80'],[null, '#643', null],[null, '#643', null],[null, '#643', null]],
            fire_sword: [[null, '#f80', null],[null, '#f60', null],[null, '#ff0', null],[null, '#643', null]],
            fire_sickle: [['#f80', '#f60', null], [null, '#643', '#f80'], [null, '#643', null], ['#643', null, null]],
            archangel_orb: [[null, '#ff0', '#ff0', null], ['#ff0', '#fff', '#fff', '#ff0'], ['#ff0', '#fff', '#fff', '#ff0'], [null, '#ff0', '#ff0', null]],
            ruins_wall: [['#666', '#777', '#666', '#555'], ['#777', '#555', null, '#666'], ['#555', '#666', '#777', null], ['#666', null, '#555', '#777']],
            artifact_box: [['#778', '#445', '#778', '#445'], ['#445', '#80f', '#40f', '#778'], ['#778', '#40f', '#80f', '#445'], ['#445', '#778', '#445', '#778']],
            technology_shard: [[null, '#0ff', null], ['#0cc', '#fff', '#0cc'], [null, '#0ff', null]],
            ancient_circuit: [['#0a0', '#fd0', '#0a0'], [null, '#fd0', null], ['#0a0', '#fd0', '#0a0']],
            astral_artifact: [[null, '#a0f', '#f0f', null], ['#a0f', '#fff', '#fff', '#f0f'], ['#f0f', '#fff', '#fff', '#a0f'], [null, '#a0f', '#f0f', null]],
            light_orb: [[null, '#ff0', null], ['#ff0', '#fff', '#ff0'], [null, '#ff0', null]],
            door: [['#864', '#975', '#864', '#975'], ['#864', '#975', '#dd0', '#975'], ['#864', '#975', '#864', '#975'], ['#864', '#975', '#864', '#975']],
            chest: [['#a85', '#c96', '#c96', '#a85'], ['#864', '#643', '#643', '#864'], ['#864', '#a85', '#ff0', '#a85'], ['#864', '#a85', '#a85', '#864']],
            mysterious_artifact: [['#f0f', '#0ff', '#f0f'], ['#0ff', '#fff', '#0ff'], ['#f0f', '#0ff', '#f0f']],
            bed: [['#964', '#964', '#964', '#964'],['#964', '#a75', '#a75', '#964'],['#fff', '#ddd', '#ddd', '#fff'],['#964', '#964', '#964', '#964']],
            berry: [[null, '#c00', '#c00', null], ['#f00', '#f55', '#f55', '#f00'], ['#f00', '#f55', '#f00', null], [null, '#c00', null, null]],
            withered_grass: [[null, '#dd0', '#cc0', null], ['#cc0', '#dd0', '#bb0', '#dd0'], ['#bb0', '#cc0', '#aa0', '#cc0'], [null, '#aa0', '#990', null]],
            berry_bush: (hasBerries) => [
                [null, '#282', hasBerries ? '#f00' : '#393', '#282'],
                ['#393', hasBerries ? '#f00' : '#282', '#393', hasBerries ? '#f00' : '#282'],
                [hasBerries ? '#f00' : '#282', '#393', hasBerries ? '#f00' : '#393', '#282'],
                [null, '#393', '#282', null]
            ],
            grass_tuft: [['#dd0', null, '#cc0'], [null, '#bb0', '#dd0'], ['#dd0', '#aa0', '#cc0']],
            void_boss: [['#201', '#403', '#403', '#201'], ['#403', '#807', '#807', '#403'], ['#403', '#807', '#807', '#403'], ['#201', '#403', '#403', '#201']],
            void_orb: [[null, '#807', null], ['#807', '#f0f', '#807'], [null, '#807', null]],
            statue: [[null, '#777', null],['#666', '#555', '#666'],['#666', '#666', '#666']],
            mimic: [['#a85', '#c96', '#c96', '#a85'], ['#864', '#f00', '#f00', '#864'], ['#864', '#a85', '#ff0', '#a85'], ['#864', '#a85', '#a85', '#864']]
        };
        const drawPixelArtOnCtx = (tCtx, x, y, s, p) => {
            if (!p) return;
            const pS = s / p.length;
            for (let row = 0; row < p.length; row++) for (let col = 0; col < p[row].length; col++) {
                if (p[row][col]) { tCtx.fillStyle = p[row][col]; tCtx.fillRect(Math.floor(x + col*pS), Math.floor(y + row*pS), Math.ceil(pS), Math.ceil(pS)); }
            }
        };
        const drawPixelArt = (x, y, size, pixels) => drawPixelArtOnCtx(ctx, x, y, size, pixels);
        
        // --- Character Data ---
        const CHARACTERS = [
            {
                id: 'base',
                name: 'База',
                description: 'Начинает с базовым набором инструментов: обычная кирка, меч и топор.',
                items: [ITEM_TYPES.AXE, ITEM_TYPES.PICKAXE, ITEM_TYPES.SWORD],
                art: art.player
            },
            {
                id: 'pyromancer',
                name: 'Пироман',
                description: 'Начинает с костром, каменным мечом и топором. Обожает тепло огня.',
                items: [{type: ITEM_TYPES.CAMPFIRE, count: 1}, {type: ITEM_TYPES.STONE_SWORD, count: 1}, {type: ITEM_TYPES.STONE_AXE, count: 1}],
                art: [['#f80', '#f80'],['#c40', '#c40'],['#888', '#888'],['#444', '#444']]
            },
            {
                id: 'survivalist',
                name: 'Выживалкин',
                description: 'Начинает с фонариком и каменным мечом. Не боится темноты.',
                items: [{type: ITEM_TYPES.FLASHLIGHT, count: 1}, {type: ITEM_TYPES.STONE_SWORD, count: 1}],
                art: [['#dd0', '#dd0'],['#888', '#888'],['#888', '#888'],['#444', '#444']]
            },
            {
                id: 'killer',
                name: 'Киллер',
                description: 'Начинает с мощным огненным мечом. Всё ради цели. Ангелы и люди не лечат его.',
                items: [{type: ITEM_TYPES.FIRE_SWORD, count: 1}],
                art: [['#c00', '#c00'],['#f00', '#f00'],['#888', '#888'],['#444', '#444']]
            },
            {
                id: 'medic',
                name: 'Медик',
                description: 'Способен создавать целебную мазь всего за 1 Орб Света. Знает цену жизни.',
                items: [ITEM_TYPES.AXE, ITEM_TYPES.PICKAXE], 
                art: [['#fff', '#fff'],['#afa', '#afa'],['#888', '#888'],['#444', '#444']]
            },
            {
                id: 'reaper',
                name: 'Жнец',
                description: 'Начинает с огненным серпом и быстрее передвигается, но у него в 2 раза меньше максимальное здоровье.',
                items: [{type: ITEM_TYPES.FIRE_SICKLE, count: 1}],
                art: [['#333', '#333'],['#555', '#555'],['#888', '#888'],['#444', '#444']]
            }
        ];
        let selectedCharacterId = CHARACTERS[0].id;
        let currentCharIndex = 0;
        
        // --- Handbook Data ---
        const HANDBOOK_DATA = {
            "Существа": {
                "Тень": { description: "Слабое существо тьмы. Боится света. Оставляет Шар Тьмы. Урон: 1.", art: art.shadow(false) },
                "Человек": { description: "Обычно пассивен. Оставляет случайный каменный инструмент и блоки. Урон (агрессивный): 5.", art: art.human },
                "Ангел": { description: "Светлое существо, восстанавливает рассудок. При смерти оставляет Орб Света.", art: art.angel(false) },
                "Лже-Ангел": { description: "Выглядит как ангел, но является порождением тьмы. Быстро истощает рассудок.", art: art.false_angel(false) },
                "Статуя": { description: "Скрытный враг Странной Долины. Выглядит как камень, но нападает, если подойти слишком близко. Неразрушим в покое.", art: art.statue },
                "Мимик": { description: "Лже-сундук. Слегка пульсирует (дышит). Атакует при попытке открыть.", art: art.mimic }
            },
            "Боссы": {
                 "Мутировавший Человек": { description: "Огромный и агрессивный. Атакует вблизи, нанося двойной урон (80) и отбрасывая игрока.", art: art.mutant_human },
                "Архангел": { description: "Могущественное существо. Стреляет веером из трёх энергетических шаров.", art: art.archangel },
                "Демон": { description: "Повелитель теней. Призывает на помощь двух Теней. Очень живуч.", art: art.demon },
                "Void": { description: "Древнее существо пустоты. Истощает рассудок аурой, атакует вблизи и выпускает снаряды во все стороны. HP: 1000.", art: art.void_boss }
            },
            "Предметы": {
                "Топор (Каменный)": { description: "Прочный топор. Добывает в 2 раза больше ресурсов.", art: art.stone_axe },
                "Кирка (Каменная)": { description: "Прочная кирка. Добывает в 2 раза больше ресурсов.", art: art.stone_pickaxe },
                "Меч (Каменный)": { description: "Прочный меч. Урон: 5.", art: art.stone_sword },
                "Топор (Огненный)": { description: "Мощный топор. Рубит сразу несколько деревьев. Замедляет при ношении. Урон ауры: 15/сек.", art: art.fire_axe },
                "Меч (Огненный)": { description: "Очень мощный меч. Урон: 25.", art: art.fire_sword },
                "Серп": { description: "Позволяет собирать ягоды. Слабое оружие.", art: art.sickle },
                "Целебная мазь": { description: "Восстанавливает 50 ед. рассудка.", art: art.mental_salve },
                "Ягода": { description: "Восстанавливает 20 рассудка и даёт 5 ед. щита.", art: art.berry },
                "Спальный мешок": { description: "Позволяет пропустить ночь. Есть шанс кражи.", art: art.sleeping_bag },
                "Кровать": { description: "Позволяет пропустить 8 часов. Можно использовать 3 раза.", art: art.bed },
                "Костёр": { description: "Источник света. Восстанавливает рассудок и ускоряет время. Требует дров для горения.", art: art.campfire },
                "Фонарик": { description: "Освещает область, нанося урон Теням. Урон: 10/сек.", art: art.flashlight },
                "Астральный артефакт": { description: "Увеличивает скорость и позволяет проходить сквозь стены.", art: art.astral_artifact },
                "Загадочный артефакт": { description: "Дарует одноразовый магический щит, который поглощает урон.", art: art.mysterious_artifact },
                "Сундук": { description: "Позволяет хранить предметы. Вмещает 15 стаков.", art: art.chest },
                "Дверь": { description: "Преграда, через которую может пройти только игрок.", art: art.door },
            },
            "Ресурсы": {
                "Дерево": { description: "Ресурс для создания инструментов. Добывается из деревьев.", art: art.wood_block },
                "Камень": { description: "Ресурс для создания инструментов. Добывается из скал.", art: art.stone_block },
                "Шар Тьмы": { description: "Эссенция тьмы, выпадающая из Теней.", art: art.dark_orb },
                "Орб Света": { description: "Эссенция света, выпадающая из Ангелов.", art: art.light_orb },
                "Сухая трава": { description: "Редкая трава, используется для создания спальных принадлежностей.", art: art.withered_grass },
                "Осколок Технологии": { description: "Компонент древних механизмов из руин.", art: art.technology_shard },
                "Древняя плата": { description: "Редкий компонент из руин.", art: art.ancient_circuit },
            },
            "Мир": {
                "Дерево": { description: "Источник дерева.", art: art.tree },
                "Скала": { description: "Источник камня.", art: art.rock },
                "Ягодный куст": { description: "Источник ягод. Требует времени для созревания.", art: art.berry_bush(true) },
                "Пучок сухой травы": { description: "Источник сухой травы.", art: art.grass_tuft },
                "Руины": { description: "Остатки древней цивилизации. Здесь можно найти ящики с артефактами.", art: art.ruins_wall },
            }
        };

        function getRecipes() {
            const baseRecipes = [
                { output: { type: ITEM_TYPES.STONE_AXE, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 2 }, { type: ITEM_TYPES.STONE, count: 3 }] },
                { output: { type: ITEM_TYPES.STONE_PICKAXE, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 2 }, { type: ITEM_TYPES.STONE, count: 3 }] },
                { output: { type: ITEM_TYPES.STONE_SWORD, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 1 }, { type: ITEM_TYPES.STONE, count: 2 }] },
                { output: { type: ITEM_TYPES.SICKLE, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 1 }, { type: ITEM_TYPES.STONE, count: 2 }] },
                { output: { type: ITEM_TYPES.MENTAL_SALVE, count: 1 }, ingredients: [{ type: ITEM_TYPES.DARK_ORB, count: 1 }, { type: ITEM_TYPES.STONE, count: 5 }] },
                { output: { type: ITEM_TYPES.DESPAIR_CRYSTAL, count: 1 }, ingredients: [{ type: ITEM_TYPES.ACORN, count: 1 }, { type: ITEM_TYPES.DARK_ORB, count: 2 }, { type: ITEM_TYPES.WOOD, count: 10 }] },
                { output: { type: ITEM_TYPES.SLEEPING_BAG, count: 1 }, ingredients: [{ type: ITEM_TYPES.WITHERED_GRASS, count: 5 }, { type: ITEM_TYPES.MENTAL_SALVE, count: 1 }] },
                { output: { type: ITEM_TYPES.BED, count: 1 }, ingredients: [{ type: ITEM_TYPES.SAKURA_PETAL, count: 3 }, { type: ITEM_TYPES.WOOD, count: 1 }, { type: ITEM_TYPES.LIGHT_ORB, count: 1 }] },
                { output: { type: ITEM_TYPES.CAMPFIRE, count: 1 }, ingredients: [{ type: ITEM_TYPES.STONE, count: 3 }, { type: ITEM_TYPES.WOOD, count: 3 }] },
                { output: { type: ITEM_TYPES.FLASHLIGHT, count: 1 }, ingredients: [{ type: ITEM_TYPES.LIGHT_ORB, count: 1 }, { type: ITEM_TYPES.TECHNOLOGY_SHARD, count: 2 }] },
                { output: { type: ITEM_TYPES.ASTRAL_ARTIFACT, count: 1 }, ingredients: [{ type: ITEM_TYPES.TECHNOLOGY_SHARD, count: 3 }, { type: ITEM_TYPES.ANCIENT_CIRCUIT, count: 1 }] },
                { output: { type: ITEM_TYPES.MYSTERIOUS_ARTIFACT, count: 1 }, ingredients: [
                    { type: ITEM_TYPES.TECHNOLOGY_SHARD, count: 1 }, 
                    { type: ITEM_TYPES.DESPAIR_CRYSTAL, count: 1 }, 
                    { type: ITEM_TYPES.DARK_ORB, count: 1 }, 
                    { type: ITEM_TYPES.LIGHT_ORB, count: 1 }, 
                    { type: ITEM_TYPES.FLASHLIGHT, count: 1 }
                ] },
                { output: { type: ITEM_TYPES.DOOR, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 6 }] },
                { output: { type: ITEM_TYPES.CHEST, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 8 }] },
            ];
             if (selectedCharacterId === 'medic') {
                const medicSalveRecipe = { output: { type: ITEM_TYPES.MENTAL_SALVE, count: 1 }, ingredients: [{ type: ITEM_TYPES.LIGHT_ORB, count: 1 }] };
                return baseRecipes.map(r => r.output.type.id === 'MENTAL_SALVE' ? medicSalveRecipe : r);
            }
            return baseRecipes;
        }

        // --- Utility to serialize/deserialize inventory items ---
        function serializeItem(item) {
            if (!item) return null;
            return { typeId: item.type.id, count: item.count, durability: item.durability, maxDurability: item.maxDurability };
        }
        function deserializeItem(itemData) {
            if (!itemData) return null;
            const itemType = Object.values(ITEM_TYPES).find(it => it.id === itemData.typeId);
            if (!itemType) return null;
            return { type: itemType, count: itemData.count, durability: itemData.durability, maxDurability: itemData.maxDurability };
        }

        // --- Save and Load ---
        function saveGame() {
            if (gameState !== 'playing' && gameState !== 'paused') return;
            try {
                const serializableEntities = entities.map(e => {
                    if (!e) return null;
                    return { type: e.type, x: e.x, y: e.y, health: e.health, aggressive: e.aggressive, isBoss: e.isBoss };
                }).filter(Boolean);
                const serializableDroppedItems = droppedItems.map(dItem => {
                    if (!dItem || !dItem.item) return null;
                    return { x: dItem.x, y: dItem.y, item: serializeItem(dItem.item) };
                }).filter(Boolean);
                const serializablePlacedObjects = placedObjects.map(obj => {
                    const newObj = {...obj};
                    if (obj.type === 'CHEST') {
                        newObj.inventory = obj.inventory.map(serializeItem);
                    }
                    return newObj;
                });

                const saveData = {
                    player: {
                        x: player.x,
                        y: player.y,
                        mentalHealth: player.mentalHealth,
                        inventory: player.inventory.map(serializeItem),
                        characterId: selectedCharacterId,
                        shield: player.shield,
                        maxShield: player.maxShield
                    },
                    gameTime: gameTime,
                    placedObjects: serializablePlacedObjects,
                    world: world,
                    entities: serializableEntities,
                    droppedItems: serializableDroppedItems,
                    growableObjects: growableObjects
                };
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            } catch (error) {
                console.error("Failed to save game:", error);
            }
        }

        function loadGame() {
            const savedDataString = localStorage.getItem(SAVE_KEY);
            if (!savedDataString) {
                showNotification("Сохранение не найдено.");
                return false;
            }
            
            try {
                const data = JSON.parse(savedDataString);
                
                selectedCharacterId = data.player.characterId || 'base';
                initGame({ loadingSave: true }); 

                player.x = data.player.x;
                player.y = data.player.y;
                player.mentalHealth = data.player.mentalHealth;
                player.shield = data.player.shield || 0;
                player.maxShield = data.player.maxShield || 100;
                player.inventory = data.player.inventory.map(deserializeItem);
                gameTime = data.gameTime;
                
                placedObjects = (data.placedObjects || []).map(obj => {
                    const newObj = {...obj};
                    if (obj.type === 'CHEST') {
                        newObj.inventory = obj.inventory.map(deserializeItem);
                    }
                    return newObj;
                });
                
                world = data.world;
                growableObjects = data.growableObjects || [];

                entities = [];
                if (data.entities) {
                    data.entities.forEach(eData => {
                        if (eData) {
                            const entityTypeKey = Object.keys(ENTITY_TYPES).find(key => ENTITY_TYPES[key] === eData.type);
                            if (entityTypeKey) spawnEntity(eData.type, null, null, eData);
                        }
                    });
                }

                droppedItems = [];
                if (data.droppedItems) {
                    data.droppedItems.forEach(dItemData => {
                        if (dItemData && dItemData.item) {
                            const item = deserializeItem(dItemData.item);
                            if (item) {
                                droppedItems.push({ x: dItemData.x, y: dItemData.y, item });
                            }
                        }
                    });
                }

                startScreen.style.display = 'none';
                characterSelectScreen.style.display = 'none';
                updateUI();
                showNotification("Игра загружена.");
                return true;

            } catch (e) {
                console.error("Error loading save:", e);
                showNotification("Файл сохранения поврежден. Начинается новая игра.");
                localStorage.removeItem(SAVE_KEY);
                return false;
            }
        }


        // --- A* Pathfinding ---
        function findPath(entity, startX, startY, endX, endY) {
            const openList = [], closedList = [];
            const maxIterations = 2000; 
            let iterations = 0;
            const startNode = { x: startX, y: startY, g: 0, h: Math.abs(endX - startX) + Math.abs(endY - startY), f: 0, parent: null };
            startNode.f = startNode.h; openList.push(startNode);
            while (openList.length > 0 && iterations < maxIterations) {
                iterations++;
                let lowInd = 0;
                for (let i = 0; i < openList.length; i++) { if (openList[i].f < openList[lowInd].f) lowInd = i; }
                const currentNode = openList[lowInd];
                if (currentNode.x === endX && currentNode.y === endY) {
                    let curr = currentNode; const ret = [];
                    while (curr.parent) { ret.push({x: curr.x * TILE_SIZE + TILE_SIZE / 2, y: curr.y * TILE_SIZE + TILE_SIZE / 2}); curr = curr.parent; }
                    return ret.reverse();
                }
                openList.splice(lowInd, 1); closedList.push(currentNode);
                const neighbors = []; const x = currentNode.x; const y = currentNode.y;
                if (x > 0) neighbors.push({ x: x - 1, y }); if (x < WORLD_WIDTH - 1) neighbors.push({ x: x + 1, y });
                if (y > 0) neighbors.push({ x, y: y - 1 }); if (y < WORLD_HEIGHT - 1) neighbors.push({ x, y: y + 1 });
                for (const neighbor of neighbors) {
                    if (isPathfindingSolid(neighbor.x, neighbor.y) || closedList.some(n => n.x === neighbor.x && n.y === neighbor.y)) continue;
                    const gScore = currentNode.g + 1; let gScoreIsBest = false;
                    let neighborNode = openList.find(n => n.x === neighbor.x && n.y === neighbor.y);
                    if (!neighborNode) {
                        gScoreIsBest = true; neighborNode = { x: neighbor.x, y: neighbor.y, h: Math.abs(endX - neighbor.x) + Math.abs(endY - neighbor.y), parent: currentNode };
                        openList.push(neighborNode);
                    } else if (gScore < neighborNode.g) gScoreIsBest = true;
                    if (gScoreIsBest) { neighborNode.parent = currentNode; neighborNode.g = gScore; neighborNode.f = neighborNode.g + neighborNode.h; }
                }
            }
            return null; 
        }

        // --- Game Loop ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;
            ENTITY_DESPAWN_RADIUS = Math.max(canvas.width, canvas.height) * 1.5;
        }
        
        function initGame(options = {}) {
            const { loadingSave = false } = options;
            resizeCanvas();

            sleepOverlay = document.getElementById('sleep-overlay');
            player = { 
                x: (WORLD_WIDTH * TILE_SIZE) / 2, y: (WORLD_HEIGHT * TILE_SIZE) / 2, 
                speed: 150, mentalHealth: 100, maxMentalHealth: 100,
                shield: 0, maxShield: 100,
                inventory: Array(21).fill(null), // 20 + 1 drop slot
                attackCooldown: 0, stunTimer: 0, 
                pickupCooldown: 0, knockback: {x: 0, y: 0}, isSleeping: false 
            };
            
            if (selectedCharacterId === 'reaper') {
                player.speed *= 1.25; // 25% faster
                player.maxMentalHealth = 50;
                player.mentalHealth = 50;
            }

            camera = { x: 0, y: 0 };
            entities = [];
            placedObjects = [];
            droppedItems = [];
            traps = [];
            projectiles = [];
            growableObjects = [];
            mousePos = { x: canvas.width / 2, y: canvas.height / 2 };

            if (!loadingSave) {
                gameTime = DAY_DURATION_SECONDS * 0.25;
                world = Array(WORLD_WIDTH).fill(0).map(() => Array(WORLD_HEIGHT).fill(TILE_TYPES.EMPTY));
                generateWorld();
                
                const character = CHARACTERS.find(c => c.id === selectedCharacterId);
                if (character && character.items) {
                    character.items.forEach(itemOrType => {
                        if (itemOrType.type) { // It's an object {type, count}
                            addItemToInventory(itemOrType.type, itemOrType.count);
                        } else { // It's just an ITEM_TYPE
                            addItemToInventory(itemOrType);
                        }
                    });
                } else { // Fallback
                    addItemToInventory(ITEM_TYPES.AXE);
                    addItemToInventory(ITEM_TYPES.PICKAXE);
                    addItemToInventory(ITEM_TYPES.SWORD);
                }
            }

            gameState = 'playing';
            gameOverScreen.style.display = 'none';
            lastTime = performance.now();
            
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(saveGame, 15000); // Auto-save every 15 seconds
            
            requestAnimationFrame(gameLoop);
        }
        
        function generateWorld() {
            const biomeMapWidth = Math.ceil(WORLD_WIDTH / BIOME_SIZE);
            const biomeMapHeight = Math.ceil(WORLD_HEIGHT / BIOME_SIZE);
            biomeMap = Array(biomeMapWidth).fill(0).map(() => Array(biomeMapHeight).fill(0));
            const biomeKeys = Object.values(BIOME_TYPES);
            for (let bx = 0; bx < biomeMapWidth; bx++) {
                for (let by = 0; by < biomeMapHeight; by++) {
                    const rand = Math.random();
                    if (rand < 0.05) biomeMap[bx][by] = BIOME_TYPES.STRANGE_VALLEY;
                    else if (rand < 0.2) biomeMap[bx][by] = BIOME_TYPES.MINE;
                    else biomeMap[bx][by] = biomeKeys[Math.floor(Math.random() * (biomeKeys.length - 2))]; // -2 to exclude new biomes from random pick here
                }
            }
            
            growableObjects = [];

            for (let x = 0; x < WORLD_WIDTH; x++) {
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    const biomeX = Math.floor(x / BIOME_SIZE);
                    const biomeY = Math.floor(y / BIOME_SIZE);
                    const currentBiome = biomeMap[biomeX][biomeY];
                    const n = Math.random();
                    world[x][y] = TILE_TYPES.EMPTY;

                    if (currentBiome === BIOME_TYPES.MINE) {
                         if (Math.random() > 0.90) world[x][y] = TILE_TYPES.ROCK;
                    } else if (currentBiome === BIOME_TYPES.STRANGE_VALLEY) {
                         if (Math.random() > 0.995) {
                             // Statues look like rocks but are entities
                             spawnEntity(ENTITY_TYPES.STATUE, x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2);
                         } else if (Math.random() > 0.998) {
                             // Mimics
                             spawnEntity(ENTITY_TYPES.MIMIC, x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2);
                         } else if (Math.random() > 0.999) {
                             // Real chests in strange valley
                             placedObjects.push({ 
                                 type: 'CHEST', x: x * TILE_SIZE + TILE_SIZE/2, y: y * TILE_SIZE + TILE_SIZE/2, 
                                 inventory: generateLoot('STRANGE_VALLEY') 
                             });
                         }
                    } else {
                        // Standard generation
                        if (Math.random() > 0.98) world[x][y] = TILE_TYPES.ROCK;
                        if (Math.random() > 0.98 && world[x][y] === TILE_TYPES.EMPTY) {
                            world[x][y] = TILE_TYPES.BERRY_BUSH;
                            growableObjects.push({ x, y, type: 'BERRY_BUSH', growth: Math.random() * BERRY_GROWTH_TIME });
                        }
                        if (Math.random() > 0.98 && world[x][y] === TILE_TYPES.EMPTY) {
                            world[x][y] = TILE_TYPES.GRASS_TUFT;
                        }

                        if (world[x][y] === TILE_TYPES.EMPTY) {
                            let treeChance = (currentBiome === BIOME_TYPES.PLAINS) ? 0.998 : 0.96;
                            if (n > treeChance) {
                                 switch(currentBiome) {
                                    case BIOME_TYPES.FOREST:
                                    case BIOME_TYPES.PLAINS:
                                        world[x][y] = TILE_TYPES.TREE;
                                        break;
                                    case BIOME_TYPES.BIRCH_FOREST:
                                        world[x][y] = TILE_TYPES.BIRCH;
                                        break;
                                    case BIOME_TYPES.OAK_FOREST:
                                        world[x][y] = TILE_TYPES.OAK;
                                        break;
                                    case BIOME_TYPES.SAKURA_GROVE:
                                         world[x][y] = TILE_TYPES.SAKURA;
                                         break;
                                }
                            }
                        }
                    }
                }
            }

            const numRuins = 6 + Math.floor(Math.random() * 4); 
            for (let i = 0; i < numRuins; i++) {
                const ruinX = Math.floor(Math.random() * (WORLD_WIDTH - 20)) + 10;
                const ruinY = Math.floor(Math.random() * (WORLD_HEIGHT - 20)) + 10;
                generateRuin(ruinX, ruinY);
            }
        }
        
        function generateLoot(biome) {
            const inv = Array(15).fill(null);
            if (biome === 'STRANGE_VALLEY') {
                const count = 3 + Math.floor(Math.random() * 4);
                for(let i=0; i<count; i++) {
                     const roll = Math.random();
                     let item;
                     if (roll < 0.2) item = { type: ITEM_TYPES.TECHNOLOGY_SHARD, count: 1 + Math.floor(Math.random() * 3) };
                     else if (roll < 0.4) item = { type: ITEM_TYPES.ANCIENT_CIRCUIT, count: 1 };
                     else if (roll < 0.5) item = { type: ITEM_TYPES.FIRE_SWORD, count: 1, durability: 300, maxDurability: 300 };
                     else if (roll < 0.6) item = { type: ITEM_TYPES.FIRE_PICKAXE, count: 1, durability: 250, maxDurability: 250 };
                     else if (roll < 0.7) item = { type: ITEM_TYPES.ASTRAL_ARTIFACT, count: 1 };
                     else item = { type: ITEM_TYPES.DARK_ORB, count: 2 + Math.floor(Math.random() * 3) };
                     
                     // Find empty slot
                     for(let j=0; j<15; j++) { if(!inv[j]) { inv[j] = item; break; } }
                }
            }
            return inv;
        }

        function generateRuin(startX, startY) {
            const width = 8 + Math.floor(Math.random() * 12);
            const height = 8 + Math.floor(Math.random() * 12);
            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height; y++) {
                    if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {
                        if (Math.random() < 0.6) { 
                             if (x === startX || x === startX + width - 1 || y === startY || y === startY + height - 1) {
                                world[x][y] = TILE_TYPES.RUINS_WALL;
                             } else if (Math.random() < 0.1) {
                                world[x][y] = TILE_TYPES.RUINS_WALL;
                             }
                        }
                    }
                }
            }
            
            const numArtifacts = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numArtifacts; i++) {
                const artX = startX + 1 + Math.floor(Math.random() * (width - 2));
                const artY = startY + 1 + Math.floor(Math.random() * (height - 2));
                if (artX >= 0 && artX < WORLD_WIDTH && artY >= 0 && artY < WORLD_HEIGHT) {
                     world[artX][artY] = TILE_TYPES.ARTIFACT_BOX;
                }
            }
        }

        function gameLoop(timestamp) {
            if (gameState === 'start') return;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (gameState !== 'paused' && gameState !== 'sleeping') {
                update(deltaTime);
            }
            
            draw();
            if (gameState !== 'game_over') requestAnimationFrame(gameLoop);
        }
        
        // --- Damage and State Update ---
        function damagePlayer(amount) {
            if (player.shield > 0) {
                const shieldDamage = Math.min(amount, player.shield);
                player.shield -= shieldDamage;
                amount -= shieldDamage;
                if (player.shield <= 0) {
                    showNotification("Ваш щит сломан!");
                }
            }
            
            if (amount > 0) {
                player.mentalHealth -= amount;
            }
        }
        
        function update(dt) {
            // Handle continuous mouse hold action
            actionTimer -= dt;
            if (gameState === 'playing' && !joystick.active) {
                if (isMouseDown && player.attackCooldown <= 0) {
                    // Left click hold: only break OWN blocks
                    handleInteraction(mousePos.x, mousePos.y, true); 
                }
                if (isRightMouseDown && actionTimer <= 0) {
                     // Right click hold: fast build
                     handleInteraction(mousePos.x, mousePos.y, false, true);
                     actionTimer = 0.15; // Build speed limiter
                }
            }

            if (player.pickupCooldown > 0) player.pickupCooldown -= dt;

            let timeScale = 1;
            const hour = Math.floor((gameTime % DAY_DURATION_SECONDS) / (DAY_DURATION_SECONDS / 24));
            const isNight = hour >= 20 || hour < 5;
            if (isNight) {
                const isNearCampfire = placedObjects.some(obj => 
                    obj.type === 'CAMPFIRE' && Math.hypot(player.x - obj.x, player.y - obj.y) < CAMPFIRE_LIGHT_RADIUS
                );
                if (isNearCampfire) timeScale = 2;
            }
            
            const effectiveDt = dt * timeScale;
            gameTime += effectiveDt;

            const selectedItem = player.inventory[selectedHotbarSlot];
            const isHoldingAstral = selectedItem?.type === ITEM_TYPES.ASTRAL_ARTIFACT;

            if (player.stunTimer > 0) {
                player.stunTimer -= dt;
            } else {
                 if (Math.abs(player.knockback.x) > 0.1 || Math.abs(player.knockback.y) > 0.1) {
                    const knockbackMoveX = player.knockback.x * dt;
                    const knockbackMoveY = player.knockback.y * dt;
                    const nextX = player.x + knockbackMoveX;
                    const nextY = player.y + knockbackMoveY;
                    const nextGridX = Math.floor(nextX / TILE_SIZE);
                    const nextGridY = Math.floor(nextY / TILE_SIZE);

                    if (!isPhysicallySolid(nextGridX, nextGridY, player, isHoldingAstral)) {
                        player.x = nextX; player.y = nextY;
                    }
                    player.knockback.x *= 0.9; 
                    player.knockback.y *= 0.9;
                } else {
                    let currentSpeed = player.speed;
                    if (selectedItem && selectedItem.type === ITEM_TYPES.FIRE_AXE) currentSpeed *= 0.7;
                    if (isHoldingAstral) currentSpeed *= 2; 

                    let dx = 0, dy = 0;
                    if (keys['KeyW'] || keys['ArrowUp']) dy -= 1; 
                    if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
                    if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1; 
                    if (keys['KeyD'] || keys['ArrowRight']) dx += 1;
                    
                    if (joystick.active) {
                        dx += joystick.dx;
                        dy += joystick.dy;
                    }

                    if (dx !== 0 || dy !== 0) {
                        const mag = Math.sqrt(dx * dx + dy * dy);
                        const moveMagnitude = Math.min(mag, 1.0); // Cap magnitude at 1
                        const moveX = (dx / mag) * moveMagnitude * currentSpeed * dt;
                        const moveY = (dy / mag) * moveMagnitude * currentSpeed * dt;
                        
                        const nextX = player.x + moveX, nextY = player.y + moveY;
                        const nextGridX = Math.floor(nextX / TILE_SIZE);
                        const nextGridY = Math.floor(nextY / TILE_SIZE);

                        if (!isPhysicallySolid(nextGridX, nextGridY, player, isHoldingAstral)) { player.x = nextX; player.y = nextY; }
                    }
                }
            }
            
            if (selectedItem && selectedItem.type === ITEM_TYPES.FIRE_AXE) {
                entities.forEach(e => {
                    if (e.type === ENTITY_TYPES.SHADOW || e.type === ENTITY_TYPES.DEMON || (e.type === ENTITY_TYPES.HUMAN && e.aggressive) || e.type === ENTITY_TYPES.MUTANT_HUMAN) {
                        if (Math.hypot(player.x - e.x, player.y - e.y) < TILE_SIZE * 1.5) {
                            e.health -= 15 * dt; 
                            e.lastDamageSource = 'player';
                        }
                    }
                });
            }
            
            for (let i = traps.length - 1; i >= 0; i--) {
                const trap = traps[i];
                if (Math.hypot(player.x - trap.x, player.y - trap.y) < TILE_SIZE / 2) {
                    if (trap.type === 'BEAR_TRAP') {
                        player.stunTimer = PLAYER_STUN_DURATION;
                        showNotification("Вы попали в капкан!");
                    } else if (trap.type === 'TRIPWIRE') {
                        damagePlayer(30);
                        showNotification("Вы задели растяжку!");
                    }
                    traps.splice(i, 1);
                    break;
                }
            }

            damagePlayer(MENTAL_HEALTH_DRAIN_RATE * dt);
            
            updatePlacedObjects(dt);
            updateGrowables(dt);
            updateDroppedItems();
            updateProjectiles(dt);
            handleFlashlight(dt);
            updateEntities(dt);

            spawnEntities();
            despawnEntities();
            spawnTraps();
            if (player.attackCooldown > 0) player.attackCooldown -= dt;
            if (player.mentalHealth <= 0) {
                player.mentalHealth = 0;
                gameState = 'game_over';
                const day = Math.floor(gameTime / DAY_DURATION_SECONDS) + 1;
                document.getElementById('days-survived-text').textContent = `Вы прожили: ${day} дней`;
                gameOverScreen.style.display = 'flex';
                localStorage.removeItem(SAVE_KEY); 
                if (autoSaveInterval) clearInterval(autoSaveInterval);
            }
        }
        
        function isPathfindingSolid(gridX, gridY) {
            if (gridX < 0 || gridY < 0 || gridX >= WORLD_WIDTH || gridY >= WORLD_HEIGHT) return true;
            const tileType = world[gridX][gridY];
            // Treat dormant statues/mimics as solid logic if needed, but for simplicity A* mostly cares about world tiles
            // If we want enemies to navigate around statues, we'd need to check entity positions too
            return tileType === TILE_TYPES.TREE || tileType === TILE_TYPES.ROCK || tileType === TILE_TYPES.WOOD_BLOCK ||
                   tileType === TILE_TYPES.STONE_BLOCK || tileType === TILE_TYPES.BIRCH || tileType === TILE_TYPES.OAK ||
                   tileType === TILE_TYPES.SAKURA || tileType === TILE_TYPES.RUINS_WALL || tileType === TILE_TYPES.BERRY_BUSH;
        }

        function isPhysicallySolid(gridX, gridY, entity, isPhasing = false) {
            if (isPhasing) return false;
            
            if (isPathfindingSolid(gridX, gridY)) {
                return true;
            }

            if (entity !== player) {
                for (const obj of placedObjects) {
                    if (obj.type === 'DOOR' && !obj.isOpen) {
                        const objGridX = Math.floor(obj.x / TILE_SIZE);
                        const objGridY = Math.floor(obj.y / TILE_SIZE);
                        if(objGridX === gridX && objGridY === gridY) {
                            return true;
                        }
                    }
                }
                // Check against sleeping statues/mimics
                for (const e of entities) {
                    if (e === entity) continue;
                    if ((e.type === ENTITY_TYPES.STATUE && !e.aggressive) || (e.type === ENTITY_TYPES.MIMIC && !e.aggressive)) {
                         const ex = Math.floor(e.x / TILE_SIZE);
                         const ey = Math.floor(e.y / TILE_SIZE);
                         if (ex === gridX && ey === gridY) return true;
                    }
                }
            }
            return false;
        }

        function isPlayerPlaced(tileType) { return tileType === TILE_TYPES.WOOD_BLOCK || tileType === TILE_TYPES.STONE_BLOCK; }

        function updatePlacedObjects(dt) {
            for (let i = placedObjects.length - 1; i >= 0; i--) {
                const obj = placedObjects[i];
                
                if (obj.type === 'CAMPFIRE') {
                    if (obj.fuel > 0) {
                        obj.fuel -= dt;

                        const distToPlayer = Math.hypot(player.x - obj.x, player.y - obj.y);
                        if (distToPlayer < CAMPFIRE_HEAL_RADIUS) {
                            player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + CAMPFIRE_HEAL_RATE * dt);
                        }

                        entities.forEach(e => {
                            if (e && e.type === ENTITY_TYPES.SHADOW) {
                                const distToShadow = Math.hypot(e.x - obj.x, e.y - obj.y);
                                if (distToShadow < CAMPFIRE_LIGHT_RADIUS) {
                                    e.health -= CAMPFIRE_SHADOW_DAMAGE * dt;
                                    e.lastDamageSource = 'environment';
                                }
                            }
                        });
                    }
                    
                    if (obj.fuel <= 0) {
                        obj.fuel = 0;
                    }
                }
            }
        }
        
        function updateGrowables(dt) {
            growableObjects.forEach(obj => {
                if (obj.type === 'BERRY_BUSH') {
                    if (obj.growth < BERRY_GROWTH_TIME) {
                        obj.growth += dt;
                    }
                }
            });
        }

        function updateDroppedItems() {
            if (player.pickupCooldown > 0) return;
            for (let i = droppedItems.length - 1; i >= 0; i--) {
                const dItem = droppedItems[i];
                if (Math.hypot(player.x - dItem.x, player.y - dItem.y) < TILE_SIZE * 0.75) {
                    if (addItemToInventory(dItem.item.type, dItem.item.count, dItem.item.durability, dItem.item.maxDurability)) {
                         showNotification(`+${dItem.item.count} ${dItem.item.type.name}`);
                         droppedItems.splice(i, 1);
                    }
                }
            }
        }
        
        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.lifetime -= dt;

                const gridX = Math.floor(p.x / TILE_SIZE);
                const gridY = Math.floor(p.y / TILE_SIZE);

                if (p.lifetime <= 0 || isPhysicallySolid(gridX, gridY, null)) { 
                    projectiles.splice(i, 1);
                    continue;
                }
                
                if (Math.hypot(p.x - player.x, p.y - player.y) < TILE_SIZE * 0.75) {
                    damagePlayer(p.damage);
                    projectiles.splice(i, 1);
                    continue;
                }
            }
        }

        function getFlashlightAngle() {
            if (joystick.active && (joystick.dx !== 0 || joystick.dy !== 0)) {
                lastJoystickAngle = Math.atan2(joystick.dy, joystick.dx);
                return lastJoystickAngle;
            }
            if (!isTouchDevice()) {
                 return Math.atan2(mousePos.y - canvas.height / 2, mousePos.x - canvas.width / 2);
            }
            return lastJoystickAngle;
        }

        function handleFlashlight(dt) {
            const selectedItem = player.inventory[selectedHotbarSlot];
            if (!selectedItem || selectedItem.type !== ITEM_TYPES.FLASHLIGHT || gameState === 'paused' || gameState === 'sleeping') {
                return;
            }

            const angle = getFlashlightAngle();
            damageItem(selectedHotbarSlot, dt / 2); 

            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (e.type === ENTITY_TYPES.SHADOW) {
                    const dist = Math.hypot(e.x - player.x, e.y - player.y);
                    if (dist > 0 && dist < FLASHLIGHT_RANGE) {
                        const angleToShadow = Math.atan2(e.y - player.y, e.x - player.x);
                        let angleDiff = Math.abs(angle - angleToShadow);
                        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; 

                        if (angleDiff < FLASHLIGHT_CONE_ANGLE / 2) {
                            e.health -= FLASHLIGHT_DAMAGE * dt;
                            e.lastDamageSource = 'player';
                        }
                    }
                }
            }
        }

        function updateEntities(dt) {
            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (!e) continue;

                if (e.health <= 0) {
                    // Loot logic
                    if (e.type === ENTITY_TYPES.STATUE) {
                         addItemToInventory(ITEM_TYPES.STONE, 5);
                         if (Math.random() < 0.2) addItemToInventory(ITEM_TYPES.DARK_ORB, 1);
                    } else if (e.type === ENTITY_TYPES.MIMIC) {
                         addItemToInventory(ITEM_TYPES.WOOD, 3);
                         if (Math.random() < 0.5) addItemToInventory(ITEM_TYPES.TECHNOLOGY_SHARD, 1);
                    }
                    else if (e.type === ENTITY_TYPES.SHADOW && e.lastDamageSource === 'player' && Math.random() < 1/3) {
                        addItemToInventory(ITEM_TYPES.DARK_ORB, 1);
                        showNotification("+1 Шар Тьмы");
                    }
                    else if (e.type === ENTITY_TYPES.ANGEL) {
                        addItemToInventory(ITEM_TYPES.LIGHT_ORB, 1);
                        showNotification("+1 Орб Света");
                        if (e.lastDamageSource === 'player') damagePlayer(25);
                    }
                    else if (e.type === ENTITY_TYPES.HUMAN && !e.isBoss) {
                        const stoneTools = [ITEM_TYPES.STONE_AXE, ITEM_TYPES.STONE_PICKAXE, ITEM_TYPES.STONE_SWORD];
                        addItemToInventory(stoneTools[Math.floor(Math.random() * stoneTools.length)]);
                        const blockType = Math.random() < 0.5 ? ITEM_TYPES.WOOD : ITEM_TYPES.STONE;
                        addItemToInventory(blockType, 30);
                    }

                    if (e.isBoss) {
                        const drops = [ITEM_TYPES.FIRE_AXE, ITEM_TYPES.FIRE_PICKAXE, ITEM_TYPES.FIRE_SWORD, ITEM_TYPES.FIRE_SICKLE];
                        addItemToInventory(drops[Math.floor(Math.random() * drops.length)]);
                    }
                    entities.splice(i, 1);
                    continue;
                }

                if (e.hitTimer > 0) e.hitTimer -= dt;
                if (e.attackCooldown > 0) e.attackCooldown -= dt;

                // Statue/Mimic Wake Up Logic
                if (e.type === ENTITY_TYPES.STATUE || e.type === ENTITY_TYPES.MIMIC) {
                    if (!e.aggressive) {
                        const dist = Math.hypot(e.x - player.x, e.y - player.y);
                        if (dist < TILE_SIZE * 2.5) {
                            e.aggressive = true;
                            e.aggressionTimer = 9999;
                            showNotification(e.type === ENTITY_TYPES.STATUE ? "Статуя ожила!" : "Это не сундук!");
                        }
                        continue; // Skip movement if sleeping
                    }
                }

                let moveX = 0, moveY = 0;
                let isKnockedBack = Math.abs(e.knockback.x) > 0.1 || Math.abs(e.knockback.y) > 0.1;

                if (isKnockedBack) {
                    moveX = e.knockback.x * dt;
                    moveY = e.knockback.y * dt;
                    e.knockback.x *= 0.9; 
                    e.knockback.y *= 0.9;
                } else {
                    if (e.isBoss || (e.type === ENTITY_TYPES.HUMAN && e.aggressive) || e.type === ENTITY_TYPES.SHADOW || ((e.type === ENTITY_TYPES.STATUE || e.type === ENTITY_TYPES.MIMIC) && e.aggressive)) {
                        let target = {x: player.x, y: player.y};
                        if (e.type === ENTITY_TYPES.SHADOW) {
                            let closestDist = Math.hypot(e.x - player.x, e.y - player.y);
                            entities.forEach(otherE => {
                                if (otherE && otherE.type === ENTITY_TYPES.HUMAN && !otherE.aggressive) {
                                    const dist = Math.hypot(e.x - otherE.x, e.y - otherE.y);
                                    if (dist < closestDist) { closestDist = dist; target = otherE; }
                                }
                            });
                        }

                        e.pathUpdateTimer -= dt;
                        if (e.pathUpdateTimer <= 0) {
                            e.pathUpdateTimer = e.isBoss ? 0.5 : 1.0;
                            e.path = findPath(e, Math.floor(e.x / TILE_SIZE), Math.floor(e.y / TILE_SIZE), Math.floor(target.x / TILE_SIZE), Math.floor(target.y / TILE_SIZE));
                            if (!e.path && e.type !== ENTITY_TYPES.SHADOW) e.moveTimer = 0;
                        }
                        
                        if (e.path && e.path.length > 0) {
                            const pathTarget = e.path[0], angle = Math.atan2(pathTarget.y - e.y, pathTarget.x - e.x);
                            moveX = Math.cos(angle) * e.speed * dt; moveY = Math.sin(angle) * e.speed * dt;
                            if (Math.hypot(pathTarget.y - e.y, pathTarget.x - e.x) < TILE_SIZE / 2) e.path.shift();
                        } else if (e.type === ENTITY_TYPES.SHADOW) {
                            e.moveTimer -= dt;
                            if (e.moveTimer <= 0) { e.angle = Math.random() * Math.PI * 2; e.moveTimer = Math.random() * 2 + 1; }
                            moveX = Math.cos(e.angle) * e.speed * 0.5 * dt; moveY = Math.sin(e.angle) * e.speed * 0.5 * dt;
                        }
                    } else if (e.type === ENTITY_TYPES.ANGEL || e.type === ENTITY_TYPES.FALSE_ANGEL || (e.type === ENTITY_TYPES.HUMAN && !e.aggressive)) {
                        e.moveTimer -= dt;
                        if (e.moveTimer <= 0) { e.angle = Math.random() * Math.PI * 2; e.moveTimer = Math.random() * 3 + 2; }
                        moveX = Math.cos(e.angle) * e.speed * dt; moveY = Math.sin(e.angle) * e.speed * dt;
                        
                        if (e.type === ENTITY_TYPES.ANGEL) {
                            if (selectedCharacterId !== 'killer' && Math.hypot(e.x - player.x, e.y - player.y) < ANGEL_HEAL_RADIUS) {
                                player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + ANGEL_HEAL_RATE * dt);
                            }
                            entities.forEach(shadow => {
                                if (shadow && shadow.type === ENTITY_TYPES.SHADOW && Math.hypot(e.x - shadow.x, e.y - shadow.y) < ANGEL_HEAL_RADIUS) {
                                    shadow.health -= ANGEL_SHADOW_DAMAGE * dt;
                                    shadow.lastDamageSource = 'environment';
                                }
                            });
                        } else if (e.type === ENTITY_TYPES.FALSE_ANGEL) {
                             if (Math.hypot(e.x - player.x, e.y - player.y) < ANGEL_HEAL_RADIUS) damagePlayer(30 * dt);
                        }
                        else if (e.type === ENTITY_TYPES.VOID) {
                           if (Math.hypot(e.x - player.x, e.y - player.y) < VOID_AURA_RADIUS) {
                                damagePlayer(VOID_AURA_DAMAGE * dt);
                            }
                        }
                        
                        if (e.type === ENTITY_TYPES.HUMAN && !e.aggressive && selectedCharacterId !== 'killer' && Math.hypot(e.x - player.x, e.y - player.y) < HUMAN_HEAL_RADIUS) {
                             player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + HUMAN_HEAL_RATE * dt);
                        }
                    }
                }

                if (e.attackCooldown <= 0) {
                    const distToPlayer = Math.hypot(e.x - player.x, e.y - player.y);
                    
                    if (e.isBoss) {
                        if (e.type === ENTITY_TYPES.ARCHANGEL && distToPlayer < TILE_SIZE * 10) {
                            const angleToPlayer = Math.atan2(player.y - e.y, player.x - e.x);
                            const projectileSpeed = 200;
                            for (let k = -1; k <= 1; k++) {
                                const angle = angleToPlayer + (k * Math.PI / 16);
                                projectiles.push({ x: e.x, y: e.y, vx: Math.cos(angle) * projectileSpeed, vy: Math.sin(angle) * projectileSpeed, lifetime: 6, damage: e.damage, art: art.archangel_orb });
                            }
                            e.attackCooldown = 3.5;
                        }
                        else if (e.type === ENTITY_TYPES.MUTANT_HUMAN && distToPlayer < TILE_SIZE * 2) {
                            damagePlayer(e.damage * 2);
                            const angle = Math.atan2(player.y - e.y, player.x - e.x);
                            player.knockback.x = Math.cos(angle) * 500;
                            player.knockback.y = Math.sin(angle) * 500;
                            e.attackCooldown = 2.5;
                        }
                        else if (e.type === ENTITY_TYPES.DEMON && distToPlayer < TILE_SIZE * 8) {
                            for (let k = 0; k < 2; k++) {
                                const spawnAngle = Math.random() * Math.PI * 2;
                                const spawnDist = TILE_SIZE * 1.5;
                                spawnEntity(ENTITY_TYPES.SHADOW, e.x + Math.cos(spawnAngle) * spawnDist, e.y + Math.sin(spawnAngle) * spawnDist);
                            }
                            showNotification("Демон призывает тени!");
                            e.attackCooldown = 6;
                        }
                         else if (e.type === ENTITY_TYPES.VOID) {
                            if (distToPlayer < TILE_SIZE * 2) {
                                damagePlayer(e.damage * 2);
                                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                                player.knockback.x = Math.cos(angle) * 500;
                                player.knockback.y = Math.sin(angle) * 500;
                                e.attackCooldown = 2.5;
                            } 
                            else if (distToPlayer < TILE_SIZE * 12) {
                                const projectileSpeed = 150;
                                const numProjectiles = 12;
                                for (let k = 0; k < numProjectiles; k++) {
                                    const angle = (k / numProjectiles) * Math.PI * 2;
                                    projectiles.push({ x: e.x, y: e.y, vx: Math.cos(angle) * projectileSpeed, vy: Math.sin(angle) * projectileSpeed, lifetime: 8, damage: e.damage / 2, art: art.void_orb });
                                }
                                e.attackCooldown = 5;
                            }
                        }
                    } 
                    else if (((e.type === ENTITY_TYPES.HUMAN && e.aggressive) || e.type === ENTITY_TYPES.SHADOW || ((e.type === ENTITY_TYPES.STATUE || e.type === ENTITY_TYPES.MIMIC) && e.aggressive)) && distToPlayer < TILE_SIZE * 1.5) {
                        damagePlayer(e.damage);
                        e.attackCooldown = 1.5;
                    }
                }

                const nextX = e.x + moveX, nextY = e.y + moveY;
                const nextGridX = Math.floor(nextX / TILE_SIZE);
                const nextGridY = Math.floor(nextY / TILE_SIZE);
                if (!isPhysicallySolid(nextGridX, nextGridY, e)) { e.x = nextX; e.y = nextY; } 
                else { 
                    if (isKnockedBack) { e.knockback.x = 0; e.knockback.y = 0; }
                    else { e.moveTimer = 0; if (e.path) e.path = null; }
                } 
                e.x = Math.max(0, Math.min(e.x, WORLD_WIDTH * TILE_SIZE)); e.y = Math.max(0, Math.min(e.y, WORLD_HEIGHT * TILE_SIZE));
            }
        }

        function despawnEntities() {
            for (let i = entities.length - 1; i >= 0; i--) {
                const e = entities[i];
                if (!e || e.isBoss) continue;

                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                if (dist > ENTITY_DESPAWN_RADIUS) {
                    entities.splice(i, 1);
                    continue;
                }

                const gridX = Math.floor(e.x / TILE_SIZE);
                const gridY = Math.floor(e.y / TILE_SIZE);
                if (isPhysicallySolid(gridX, gridY, e)) {
                    entities.splice(i, 1);
                    continue;
                }
            }
        }

        function spawnEntities() {
            const day = Math.floor(gameTime / DAY_DURATION_SECONDS) + 1;
            const hour = Math.floor((gameTime % DAY_DURATION_SECONDS) / (DAY_DURATION_SECONDS / 24));
            const isNight = hour >= 20 || hour < 5;

            // Mine Logic: Shadows spawn during day if in Mine
            const gridX = Math.floor(player.x / TILE_SIZE);
            const gridY = Math.floor(player.y / TILE_SIZE);
            const biomeX = Math.floor(gridX / BIOME_SIZE);
            const biomeY = Math.floor(gridY / BIOME_SIZE);
            const inMine = biomeMap && biomeMap[biomeX] && biomeMap[biomeX][biomeY] === BIOME_TYPES.MINE;

            const maxShadows = 15;
            const currentShadows = entities.filter(e => e && e.type === ENTITY_TYPES.SHADOW).length;
            if (currentShadows < maxShadows) {
                if (isNight && Math.random() < 0.02) {
                    spawnEntity(ENTITY_TYPES.SHADOW);
                } else if (!isNight && Math.random() < 0.0005) {
                    spawnEntity(ENTITY_TYPES.SHADOW);
                } else if (inMine && Math.random() < 0.015) { // High spawn rate in mines
                    spawnEntity(ENTITY_TYPES.SHADOW);
                }
            }

            if (entities.filter(e => e && e.type === ENTITY_TYPES.ANGEL).length < 4 && Math.random() < 0.002) spawnEntity(ENTITY_TYPES.ANGEL);
            if (entities.filter(e => e && e.type === ENTITY_TYPES.HUMAN).length < 8 && Math.random() < 0.005) spawnEntity(ENTITY_TYPES.HUMAN);
            if (entities.filter(e => e && e.type === ENTITY_TYPES.FALSE_ANGEL).length < 3 && Math.random() < 0.003) spawnEntity(ENTITY_TYPES.FALSE_ANGEL);

            if (day > 3) {
                const bossExists = entities.some(e => e && e.isBoss);
                if (!bossExists && Math.random() < 0.005) {
                    const bossPool = [ENTITY_TYPES.MUTANT_HUMAN, ENTITY_TYPES.ARCHANGEL, ENTITY_TYPES.DEMON];
                    if (day > 5) {
                        bossPool.push(ENTITY_TYPES.VOID);
                    }
                    const bossType = bossPool[Math.floor(Math.random() * bossPool.length)];
                    spawnEntity(bossType);
                    showNotification("Вы чувствуете зловещее присутствие...");
                }
            }
        }
        
        function spawnTraps() {
            if (traps.length < 20 && Math.random() < 0.005) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.max(canvas.width, canvas.height);
                const x = player.x + Math.cos(angle) * radius;
                const y = player.y + Math.sin(angle) * radius;

                const gridX = Math.floor(x / TILE_SIZE), gridY = Math.floor(y / TILE_SIZE);
                if (gridX >= 0 && gridX < WORLD_WIDTH && gridY >= 0 && gridY < WORLD_HEIGHT && !isPhysicallySolid(gridX, gridY, null)) {
                    const type = Math.random() < 0.5 ? 'BEAR_TRAP' : 'TRIPWIRE';
                    traps.push({ x, y, type });
                }
            }
        }
        function spawnEntity(type, spawnX, spawnY, saveData = null) {
            const angle = Math.random() * Math.PI * 2, radius = Math.max(canvas.width, canvas.height);
            let x = saveData ? saveData.x : (spawnX ?? player.x + Math.cos(angle) * radius);
            let y = saveData ? saveData.y : (spawnY ?? player.y + Math.sin(angle) * radius);
            
            let baseHealth = 100;
            if (type === ENTITY_TYPES.SHADOW) baseHealth = 20;
            else if (type === ENTITY_TYPES.ANGEL) baseHealth = 20;
            else if (type === ENTITY_TYPES.FALSE_ANGEL) baseHealth = 50;
            else if (type === ENTITY_TYPES.MUTANT_HUMAN) baseHealth = 500;
            else if (type === ENTITY_TYPES.ARCHANGEL) baseHealth = 400;
            else if (type === ENTITY_TYPES.DEMON) baseHealth = 666;
            else if (type === ENTITY_TYPES.VOID) baseHealth = 1000;
            else if (type === ENTITY_TYPES.STATUE) baseHealth = 1500;
            else if (type === ENTITY_TYPES.MIMIC) baseHealth = 300;

            const health = saveData ? saveData.health : baseHealth;
            
            const baseEntity = { x, y, health, hitTimer: 0, knockback: { x: 0, y: 0 }, isBoss: false, path: null, pathUpdateTimer: 0, moveTimer: 0, angle: 0, attackCooldown: 0, lastDamageSource: null };
            if (saveData && saveData.isBoss) baseEntity.isBoss = true;

            if (type === ENTITY_TYPES.SHADOW) entities.push({ ...baseEntity, type, speed: 130, damage: 2 });
            else if (type === ENTITY_TYPES.ANGEL) entities.push({ ...baseEntity, type, speed: 30 });
            else if (type === ENTITY_TYPES.FALSE_ANGEL) entities.push({ ...baseEntity, type, speed: 40 });
            else if (type === ENTITY_TYPES.HUMAN) {
                const isAngry = saveData ? saveData.aggressive : ((spawnX !== undefined) ? Math.random() < 0.5 : Math.random() < 0.3);
                entities.push({ ...baseEntity, type, speed: isAngry ? 75 : 50, aggressive: isAngry, aggressionTimer: isAngry ? 30 : 0, damage: 10 });
            }
            else if (type === ENTITY_TYPES.MUTANT_HUMAN) entities.push({ ...baseEntity, isBoss: true, type, speed: 80, damage: 40, aggressive: true, attackCooldown: 2 });
            else if (type === ENTITY_TYPES.ARCHANGEL) entities.push({ ...baseEntity, isBoss: true, type, speed: 60, damage: 15, aggressive: true, attackCooldown: 3.5 });
            else if (type === ENTITY_TYPES.DEMON) entities.push({ ...baseEntity, isBoss: true, type, speed: 90, damage: 25, aggressive: true, attackCooldown: 6 });
            else if (type === ENTITY_TYPES.VOID) entities.push({ ...baseEntity, isBoss: true, type, speed: 70, damage: 40, aggressive: true, attackCooldown: 4 });
            else if (type === ENTITY_TYPES.STATUE) entities.push({ ...baseEntity, type, speed: 200, damage: 200, aggressive: false }); // Fast & instant kill basically
            else if (type === ENTITY_TYPES.MIMIC) entities.push({ ...baseEntity, type, speed: 100, damage: 30, aggressive: false });
        }
        
        // --- Rendering ---
        function draw() {
            if (!player || !world) return;

            // Biome darkness logic
            const gridX = Math.floor(player.x / TILE_SIZE);
            const gridY = Math.floor(player.y / TILE_SIZE);
            const biomeX = Math.floor(gridX / BIOME_SIZE);
            const biomeY = Math.floor(gridY / BIOME_SIZE);
            const inMine = biomeMap && biomeMap[biomeX] && biomeMap[biomeX][biomeY] === BIOME_TYPES.MINE;

            const hour = Math.floor((gameTime % DAY_DURATION_SECONDS) / (DAY_DURATION_SECONDS / 24));
            const isNight = hour >= 20 || hour < 5;
            let lightLevel = isNight ? 0.4 : 1.0;
            if (inMine) lightLevel = Math.min(lightLevel, 0.5); // Always somewhat dark in mines

            canvas.style.filter = `brightness(${lightLevel})`;
            camera.x = player.x - canvas.width / 2; camera.y = player.y - canvas.height / 2;
            ctx.clearRect(0, 0, canvas.width, canvas.height);


            const startCol = Math.floor(camera.x / TILE_SIZE), endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 1;
            const startRow = Math.floor(camera.y / TILE_SIZE), endRow = startRow + Math.ceil(canvas.height / TILE_SIZE) + 1;
           
            for (let x = startCol; x < endCol; x++) for (let y = startRow; y < endRow; y++) {
                if (x < 0 || y < 0 || x >= WORLD_WIDTH || y >= WORLD_HEIGHT) continue;
                const tile = world[x]?.[y], dX = x * TILE_SIZE - camera.x, dY = y * TILE_SIZE - camera.y;
                if (tile === TILE_TYPES.TREE) drawPixelArt(dX, dY, TILE_SIZE, art.tree);
                else if (tile === TILE_TYPES.BIRCH) drawPixelArt(dX, dY, TILE_SIZE, art.birch);
                else if (tile === TILE_TYPES.OAK) drawPixelArt(dX, dY, TILE_SIZE, art.oak);
                else if (tile === TILE_TYPES.SAKURA) drawPixelArt(dX, dY, TILE_SIZE, art.sakura);
                else if (tile === TILE_TYPES.ROCK) drawPixelArt(dX, dY, TILE_SIZE, art.rock);
                else if (tile === TILE_TYPES.WOOD_BLOCK) drawPixelArt(dX, dY, TILE_SIZE, art.wood_block);
                else if (tile === TILE_TYPES.STONE_BLOCK) drawPixelArt(dX, dY, TILE_SIZE, art.stone_block);
                else if (tile === TILE_TYPES.RUINS_WALL) drawPixelArt(dX, dY, TILE_SIZE, art.ruins_wall);
                else if (tile === TILE_TYPES.ARTIFACT_BOX) drawPixelArt(dX, dY, TILE_SIZE, art.artifact_box);
                else if (tile === TILE_TYPES.BERRY_BUSH) {
                    const bush = growableObjects.find(b => b.x === x && b.y === y);
                    const hasBerries = bush && bush.growth >= BERRY_GROWTH_TIME;
                    drawPixelArt(dX, dY, TILE_SIZE, art.berry_bush(hasBerries));
                } else if (tile === TILE_TYPES.GRASS_TUFT) {
                    drawPixelArt(dX, dY, TILE_SIZE, art.grass_tuft);
                }
            }
            
            projectiles.forEach(p => {
                const dX = p.x - camera.x - TILE_SIZE / 4;
                const dY = p.y - camera.y - TILE_SIZE / 4;
                const projArt = p.art || art.archangel_orb;
                drawPixelArt(dX, dY, TILE_SIZE / 2, projArt);
            });

            droppedItems.forEach(dItem => {
                const dX = dItem.x - camera.x; const dY = dItem.y - camera.y;
                const itemSize = TILE_SIZE * 0.6;
                let artKey = Object.keys(ITEM_TYPES).find(key => ITEM_TYPES[key].id === dItem.item.type.id)?.toLowerCase();
                if (dItem.item.type.id === 'WOOD') artKey = 'wood_block'; if (dItem.item.type.id === 'STONE') artKey = 'stone_block';
                if (art[artKey]) { drawPixelArt(dX - itemSize / 2, dY - itemSize / 2, itemSize, art[artKey]); }
            });

            placedObjects.forEach(obj => {
                const dX = obj.x - camera.x, dY = obj.y - camera.y;
                if (obj.type === 'CAMPFIRE') {
                    if (obj.fuel > 0) {
                        const gradient = ctx.createRadialGradient(dX, dY, TILE_SIZE * 0.5, dX, dY, CAMPFIRE_LIGHT_RADIUS);
                        gradient.addColorStop(0, 'rgba(255, 180, 50, 0.25)'); gradient.addColorStop(1, 'rgba(255, 180, 50, 0)');
                        ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(dX, dY, CAMPFIRE_LIGHT_RADIUS, 0, Math.PI * 2); ctx.fill();
                    }
                    drawPixelArt(dX - TILE_SIZE/2, dY - TILE_SIZE/2, TILE_SIZE, art.campfire);
                    if (obj.fuel > 0 && obj.fuel < MAX_CAMPFIRE_FUEL) {
                        const barWidth = TILE_SIZE; const barHeight = 5;
                        const barX = dX - barWidth / 2; const barY = dY + TILE_SIZE / 2 + 2;
                        ctx.fillStyle = '#333'; ctx.fillRect(barX, barY, barWidth, barHeight);
                        ctx.fillStyle = '#f80'; ctx.fillRect(barX, barY, barWidth * (obj.fuel / MAX_CAMPFIRE_FUEL), barHeight);
                    }
                } else if (obj.type === 'DOOR') {
                    drawPixelArt(dX - TILE_SIZE/2, dY - TILE_SIZE/2, TILE_SIZE, art.door);
                    if (!obj.isOpen) { ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(dX - TILE_SIZE/2, dY - TILE_SIZE/2, TILE_SIZE, TILE_SIZE); }
                } else if (obj.type === 'CHEST') {
                    drawPixelArt(dX - TILE_SIZE/2, dY - TILE_SIZE/2, TILE_SIZE, art.chest);
                } else if (obj.type === 'BED') {
                    drawPixelArt(dX - TILE_SIZE/2, dY - TILE_SIZE/2, TILE_SIZE, art.bed);
                }
            });

            entities.forEach(e => {
                if (!e) return;
                const dX = e.x - camera.x, dY = e.y - camera.y;
                let size = e.isBoss ? TILE_SIZE * 2.5 : TILE_SIZE;
                
                if (e.type === ENTITY_TYPES.SHADOW) drawPixelArt(dX - size / 2, dY - size / 2, size, art.shadow(Math.random() > 0.5));
                else if (e.type === ENTITY_TYPES.ANGEL) { ctx.beginPath(); ctx.arc(dX, dY, ANGEL_HEAL_RADIUS, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.fill(); drawPixelArt(dX - TILE_SIZE / 2, dY - TILE_SIZE / 2, TILE_SIZE, art.angel(Math.random() > 0.5)); }
                else if (e.type === ENTITY_TYPES.FALSE_ANGEL) { ctx.beginPath(); ctx.arc(dX, dY, ANGEL_HEAL_RADIUS, 0, Math.PI * 2); ctx.fillStyle = 'rgba(128, 128, 128, 0.1)'; ctx.fill(); drawPixelArt(dX - TILE_SIZE / 2, dY - TILE_SIZE / 2, TILE_SIZE, art.false_angel(Math.random() > 0.5)); }
                else if (e.type === ENTITY_TYPES.HUMAN) {
                     if (!e.aggressive) { ctx.beginPath(); ctx.arc(dX, dY, HUMAN_HEAL_RADIUS, 0, Math.PI * 2); ctx.fillStyle = 'rgba(144, 238, 144, 0.05)'; ctx.fill(); } 
                     else { ctx.beginPath(); ctx.arc(dX, dY, TILE_SIZE * 1.5, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 0, 0, 0.1)'; ctx.fill(); }
                     drawPixelArt(dX - TILE_SIZE / 2, dY - TILE_SIZE / 2, TILE_SIZE, art.human);
                }
                else if (e.type === ENTITY_TYPES.MUTANT_HUMAN) drawPixelArt(dX - size / 2, dY - size / 2, size, art.mutant_human);
                else if (e.type === ENTITY_TYPES.ARCHANGEL) drawPixelArt(dX - size / 2, dY - size / 2, size, art.archangel);
                else if (e.type === ENTITY_TYPES.DEMON) drawPixelArt(dX - size / 2, dY - size / 2, size, art.demon);
                else if (e.type === ENTITY_TYPES.VOID) {
                    ctx.beginPath(); 
                    ctx.arc(dX, dY, VOID_AURA_RADIUS, 0, Math.PI * 2); 
                    ctx.fillStyle = 'rgba(128, 0, 255, 0.1)'; 
                    ctx.fill(); 
                    drawPixelArt(dX - size / 2, dY - size / 2, size, art.void_boss);
                }
                else if (e.type === ENTITY_TYPES.STATUE) {
                    drawPixelArt(dX - TILE_SIZE / 2, dY - TILE_SIZE / 2, TILE_SIZE, art.statue);
                }
                else if (e.type === ENTITY_TYPES.MIMIC) {
                    let mimicSize = TILE_SIZE;
                    if (!e.aggressive) {
                        // Breathing effect
                        mimicSize = TILE_SIZE * (1 + Math.sin(gameTime * 3) * 0.05);
                    }
                    drawPixelArt(dX - mimicSize / 2, dY - mimicSize / 2, mimicSize, art.mimic);
                }


                if (e.hitTimer > 0) {
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.6)';
                    ctx.fillRect(dX - size / 2, dY - size / 2, size, size);
                }
            });
            
            let p_dX = player.x - camera.x;
            let p_dY = player.y - camera.y;

            if(player.stunTimer > 0) {
                ctx.fillStyle = "rgba(255, 255, 100, 0.3)";
                ctx.beginPath();
                ctx.arc(p_dX, p_dY, TILE_SIZE, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const characterArt = (CHARACTERS.find(c => c.id === selectedCharacterId) || CHARACTERS[0]).art;
            
            if (player.isSleeping) {
                 drawPixelArt(p_dX - TILE_SIZE/2, p_dY - TILE_SIZE/2, TILE_SIZE, art.player_sleeping);
            } else {
                 drawPixelArt(p_dX - TILE_SIZE/2, p_dY - TILE_SIZE/2, TILE_SIZE, characterArt);
            }
            
            // Draw Mouse Cursor Highlight on PC
            if (!isTouchDevice() && gameState === 'playing') {
                const mx = mousePos.x;
                const my = mousePos.y;
                const mGridX = Math.floor((mx + camera.x) / TILE_SIZE);
                const mGridY = Math.floor((my + camera.y) / TILE_SIZE);
                const tileX = mGridX * TILE_SIZE - camera.x;
                const tileY = mGridY * TILE_SIZE - camera.y;

                ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
                ctx.lineWidth = 2;
                ctx.strokeRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
            }

            const selectedItem = player.inventory[selectedHotbarSlot];
            
            if (selectedItem && selectedItem.type === ITEM_TYPES.FLASHLIGHT && gameState === 'playing') {
                const angle = getFlashlightAngle();
                ctx.fillStyle = 'rgba(255, 255, 220, 0.15)';
                ctx.save();
                ctx.translate(p_dX, p_dY);
                ctx.rotate(angle);
                ctx.beginPath(); ctx.moveTo(0,0);
                ctx.arc(0, 0, FLASHLIGHT_RANGE, -FLASHLIGHT_CONE_ANGLE / 2, FLASHLIGHT_CONE_ANGLE / 2);
                ctx.lineTo(0,0); ctx.fill();
                ctx.restore();
            }

            if (selectedItem && gameState === 'playing' && !player.isSleeping) {
                let artKey = Object.keys(ITEM_TYPES).find(key => ITEM_TYPES[key].id === selectedItem.type.id)?.toLowerCase();
                if (selectedItem.type.id === 'WOOD') artKey = 'wood_block';
                if (selectedItem.type.id === 'STONE') artKey = 'stone_block';
                if (art[artKey]) {
                    const itemSize = TILE_SIZE * 0.7;
                    const itemX = p_dX + TILE_SIZE * 0.1;
                    const itemY = p_dY - TILE_SIZE * 0.1;
                    drawPixelArt(itemX, itemY, itemSize, art[artKey]);
                }
            }
            
            if (gameState === 'paused') {
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fillRect(0,0,canvas.width, canvas.height);
            }
            updateUI();
        }
        
        // --- UI and Inventory ---
        function showNotification(message) {
            const container = document.getElementById('notification-container');
            const notif = document.createElement('div');
            notif.className = 'notification-message';
            notif.textContent = message;
            container.appendChild(notif);
            setTimeout(() => {
                notif.remove();
            }, 4000);
        }

        function updateUI() {
            if(!player) return;
            document.getElementById('mental-health-bar').style.width = `${(player.mentalHealth / player.maxMentalHealth) * 100}%`;
            
            const shieldBarContainer = document.getElementById('shield-bar-container');
            if(player.shield > 0) {
                shieldBarContainer.style.display = 'block';
                document.getElementById('shield-bar').style.width = `${(player.shield / player.maxShield) * 100}%`;
            } else {
                shieldBarContainer.style.display = 'none';
            }

            const day = Math.floor(gameTime / DAY_DURATION_SECONDS) + 1;
            const timeInDay = gameTime % DAY_DURATION_SECONDS;
            const hour = Math.floor(timeInDay / (DAY_DURATION_SECONDS / 24));
            const minute = Math.floor((timeInDay % (DAY_DURATION_SECONDS / 24)) / (DAY_DURATION_SECONDS / 24 / 60));
            document.getElementById('day-counter').textContent = `День ${day}`;
            document.getElementById('time-display').textContent = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
            
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            for (let i = 0; i < 5; i++) hotbar.appendChild(createSlotElement(player.inventory, i, 'hotbar'));
        }
        
        function createSlotElement(inventory, i, type) {
            const slot = document.createElement('div');
            slot.className = type === 'hotbar' ? 'hotbar-slot' : 'inventory-slot';
            if (type !== 'hotbar') slot.classList.add('hotbar-slot'); 
            
            slot.classList.toggle('selected', type === 'hotbar' && i === selectedHotbarSlot);
            slot.dataset.slotIndex = i;
            slot.dataset.inventory = (type === 'chest') ? 'chest' : 'player';

            // The drop slot should ONLY appear in the main player inventory view.
            if (type === 'player-main' && i === player.inventory.length - 1) {
                slot.classList.add('drop-slot');
                slot.innerHTML = `<svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></svg>`;
                slot.title = "Выбросить предмет";
                return slot; 
            }
            
            const item = inventory[i];
            slot.draggable = item != null;
            
            if (item) {
                const iconSize = 64; 
                const canvasIcon = document.createElement('canvas');
                canvasIcon.width = canvasIcon.height = iconSize; canvasIcon.className = 'item-icon';
                const iconCtx = canvasIcon.getContext('2d'); iconCtx.imageSmoothingEnabled = false;
                
                let artKey = Object.keys(ITEM_TYPES).find(key => ITEM_TYPES[key].id === item.type.id)?.toLowerCase();
                if (item.type.id === 'WOOD') artKey = 'wood_block';
                if (item.type.id === 'STONE') artKey = 'stone_block';
                
                if (art[artKey]) {
                    drawPixelArtOnCtx(iconCtx, 0, 0, iconSize, art[artKey]);
                }
                slot.appendChild(canvasIcon);
                
                if (item.count > 1) {
                    const itemCount = document.createElement('span'); itemCount.className = 'item-count';
                    itemCount.innerText = item.count; slot.appendChild(itemCount);
                }

                if (item.durability !== undefined) {
                    const durabilityBar = document.createElement('div');
                    durabilityBar.className = 'durability-bar';
                    const innerBar = document.createElement('div');
                    innerBar.className = 'durability-bar-inner';
                    const percentage = (item.durability / item.maxDurability) * 100;
                    innerBar.style.width = `${percentage}%`;
                    if (percentage > 60) innerBar.style.backgroundColor = '#4caf50';
                    else if (percentage > 25) innerBar.style.backgroundColor = '#ffeb3b';
                    else innerBar.style.backgroundColor = '#f44336';
                    durabilityBar.appendChild(innerBar);
                    slot.appendChild(durabilityBar);
                }
            }
            return slot;
        }

        function toggleInventory() {
            if (gameState === 'game_over' || handbookScreen.style.display === 'flex' || chestScreen.style.display === 'flex' || gameState === 'sleeping') return;
            const isOpening = gameState !== 'paused';
            gameState = isOpening ? 'paused' : 'playing';
            inventoryScreen.style.display = isOpening ? 'flex' : 'none';
            if (isOpening) {
                selectedRecipe = null;
                updateInventoryScreen();
            }
        }
        function toggleChestScreen(chest = null) {
            if (gameState === 'game_over' || handbookScreen.style.display === 'flex' || inventoryScreen.style.display === 'flex' || gameState === 'sleeping') return;
             const isOpening = chestScreen.style.display === 'none';
             if (isOpening && chest) {
                activeChest = chest;
                gameState = 'paused';
                chestScreen.style.display = 'flex';
                updateChestScreen();
             } else {
                activeChest = null;
                gameState = 'playing';
                chestScreen.style.display = 'none';
             }
        }
        function updateInventoryScreen() {
            const inventoryGrid = document.getElementById('inventory-grid');
            inventoryGrid.innerHTML = '';
            for (let i = 0; i < player.inventory.length; i++) inventoryGrid.appendChild(createSlotElement(player.inventory, i, 'player-main'));
            updateRecipeList();
        }
        function updateChestScreen() {
            if (!activeChest) return;
            const playerGrid = document.getElementById('player-chest-grid');
            const chestGrid = document.getElementById('chest-grid');
            playerGrid.innerHTML = '';
            chestGrid.innerHTML = '';
            for (let i = 0; i < player.inventory.length; i++) playerGrid.appendChild(createSlotElement(player.inventory, i, 'player-chest'));
            for (let i = 0; i < activeChest.inventory.length; i++) chestGrid.appendChild(createSlotElement(activeChest.inventory, i, 'chest'));
        }
        function updateRecipeList() {
            const recipeList = document.getElementById('recipe-list');
            recipeList.innerHTML = '';
            const availableRecipes = getRecipes();
            availableRecipes.forEach((recipe, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${recipe.output.type.name} x${recipe.output.count}</span>`;
                li.dataset.recipeIndex = index;
                const canCraft = canCraftRecipe(recipe);
                li.classList.toggle('un-craftable', !canCraft);
                li.classList.toggle('selected', selectedRecipe === recipe);
                li.addEventListener('click', () => { 
                    selectedRecipe = selectedRecipe === recipe ? null : recipe;
                    updateRecipeList();
                });
                recipeList.appendChild(li);
            });
            updateCraftingDetails();
        }
        function updateCraftingDetails() {
            const details = document.getElementById('crafting-details');
            const button = document.getElementById('craft-button');
            if (!selectedRecipe) {
                details.innerHTML = `<p style="font-size: 14px; color: #777;">Выберите рецепт</p>`;
                button.disabled = true;
                return;
            }
            const canCraft = canCraftRecipe(selectedRecipe);
            let detailsHtml = `<h4 style="margin: 0 0 10px 0; color: #fff;">${selectedRecipe.output.type.name}</h4><ul style="padding-left: 0;">`;
            selectedRecipe.ingredients.forEach(ing => {
                const hasCount = countItems(ing.type);
                const hasEnough = hasCount >= ing.count;
                detailsHtml += `<li class="${!hasEnough ? 'needed-bad' : ''}" style="list-style: none; color: #aaa; margin-bottom: 4px;">${ing.type.name}: ${hasCount}/${ing.count}</li>`;
            });
            detailsHtml += `</ul>`;
            details.innerHTML = detailsHtml;
            button.disabled = !canCraft;
        }
        document.getElementById('craft-button').addEventListener('click', () => {
            if (selectedRecipe && canCraftRecipe(selectedRecipe)) {
                craftRecipe(selectedRecipe);
                updateInventoryScreen();
            }
        });

        // --- Item and Crafting Logic ---
        function countItems(itemType) {
            return player.inventory.reduce((sum, item) => item && item.type.id === itemType.id ? sum + item.count : sum, 0);
        }
        function canCraftRecipe(recipe) {
            return recipe.ingredients.every(ing => countItems(ing.type) >= ing.count);
        }
        function craftRecipe(recipe) {
            if (!canCraftRecipe(recipe)) return;
            recipe.ingredients.forEach(ing => removeItemFromInventory(player.inventory, ing.type, ing.count));
            addItemToInventory(recipe.output.type, recipe.output.count);
        }
        function addItemToInventory(itemType, count = 1, durability, maxDurability) {
            const targetInventory = player.inventory;
            const inventorySize = targetInventory.length -1; // Exclude drop slot
            if (itemType.durability) {
                // Special case for flashlight in mysterious artifact recipe
                if (itemType.id === 'MYSTERIOUS_ARTIFACT') {
                    const flashlight = targetInventory.find(item => item && item.type.id === 'FLASHLIGHT');
                    if (flashlight) {
                         removeItemFromInventory(targetInventory, ITEM_TYPES.FLASHLIGHT, 1);
                    }
                }
                for (let i = 0; i < inventorySize; i++) {
                    if (!targetInventory[i]) {
                        targetInventory[i] = {
                            type: itemType,
                            count: 1,
                            durability: durability !== undefined ? durability : itemType.durability,
                            maxDurability: maxDurability !== undefined ? maxDurability : itemType.durability
                        };
                        return true;
                    }
                }
                return false;
            }

            for (let i = 0; i < inventorySize; i++) {
                if (targetInventory[i] && targetInventory[i].type.id === itemType.id) {
                    targetInventory[i].count += count;
                    return true;
                }
            }
            for (let i = 0; i < inventorySize; i++) {
                if (!targetInventory[i]) {
                    targetInventory[i] = { type: itemType, count };
                    return true;
                }
            }
            return false;
        }
        function removeItemFromInventory(inventory, itemType, count) {
            if (itemType.durability) { // Handle tools like flashlight
                for (let i = 0; i < inventory.length; i++) {
                    if (count <= 0) break;
                    const item = inventory[i];
                    if (item && item.type.id === itemType.id) {
                        inventory[i] = null;
                        count--;
                    }
                }
            } else { // Handle stackable items
                for (let i = inventory.length - 1; i >= 0; i--) {
                    if (count <= 0) break;
                    const item = inventory[i];
                    if (item && item.type.id === itemType.id) {
                        const toRemove = Math.min(count, item.count);
                        item.count -= toRemove;
                        count -= toRemove;
                        if (item.count <= 0) inventory[i] = null;
                    }
                }
            }
            return count <= 0;
        }
         function damageItem(slotIndex, amount = 1) {
            const item = player.inventory[slotIndex];
            if (item && item.durability !== undefined) {
                item.durability -= amount;
                if (item.durability <= 0) {
                    showNotification(`${item.type.name} сломался!`);
                    player.inventory[slotIndex] = null;
                }
            }
        }
        
        // --- Interaction and Animations ---
        function startSleepAnimation() {
            if (gameState !== 'playing') return;

            gameState = 'sleeping';
            player.isSleeping = true;

            setTimeout(() => {
                sleepOverlay.style.opacity = '1';
                setTimeout(() => {
                    const currentDay = Math.floor(gameTime / DAY_DURATION_SECONDS);
                    const nextDayStart = (currentDay + 1) * DAY_DURATION_SECONDS;
                    const randomHourFraction = (6 + Math.random() * 3) / 24;
                    gameTime = nextDayStart + DAY_DURATION_SECONDS * randomHourFraction;
                    
                    player.mentalHealth = player.maxMentalHealth;
                    removeItemFromInventory(player.inventory, ITEM_TYPES.SLEEPING_BAG, 1);
                    if (Math.random() < 0.20) {
                        const itemsInInventory = player.inventory.map((item, index) => ({item, index})).filter(i => i.item != null && i.index < player.inventory.length-1);
                        if (itemsInInventory.length > 0) {
                            const stolen = itemsInInventory[Math.floor(Math.random() * itemsInInventory.length)];
                            const amountToRemove = Math.min(stolen.item.count, Math.floor(Math.random() * 5) + 1);
                            showNotification(`Пока ты спал, у тебя украли ${stolen.item.type.name} в количестве ${amountToRemove}`);
                            removeItemFromInventory(player.inventory, stolen.item.type, amountToRemove);
                        }
                    }
                    showNotification("Вы просыпаетесь, чувствуя себя отдохнувшим.");

                    sleepOverlay.style.opacity = '0';
                    
                    setTimeout(() => {
                        player.isSleeping = false;
                        gameState = 'playing';
                    }, 1500);

                }, 1500);
            }, 500);
        }

        function useBed(bedObject) {
            if (gameState !== 'playing' || !bedObject || bedObject.uses <= 0) return;

            gameState = 'sleeping';
            player.isSleeping = true;
            
            setTimeout(() => {
                sleepOverlay.style.opacity = '1';
                setTimeout(() => {
                    // Advance time by 8 hours
                    gameTime += (DAY_DURATION_SECONDS / 24) * 8;
                    
                    bedObject.uses--;
                    
                    if (bedObject.uses <= 0) {
                        const index = placedObjects.findIndex(obj => obj === bedObject);
                        if (index > -1) {
                            placedObjects.splice(index, 1);
                        }
                        showNotification("Кровать сломалась.");
                    } else {
                        showNotification("Вы отдохнули.");
                    }

                    sleepOverlay.style.opacity = '0';
                    
                    setTimeout(() => {
                        player.isSleeping = false;
                        gameState = 'playing';
                    }, 1500);

                }, 1500);
            }, 500);
        }

        function handleInteraction(clientX, clientY, isContinuous = false, isRightClick = false) {
            if (gameState !== 'playing' || player.attackCooldown > 0 || player.stunTimer > 0) return;
            if (isTouchDevice()) {
                const joyRect = joystickContainer.getBoundingClientRect();
                if (clientX >= joyRect.left && clientX <= joyRect.right && clientY >= joyRect.top && clientY <= joyRect.bottom) return;
                const bottomUiRect = document.getElementById('bottom-ui').getBoundingClientRect();
                 if (clientY >= bottomUiRect.top) return;
            }
            const mouseX = clientX + camera.x, mouseY = clientY + camera.y;
            const gridX = Math.floor(mouseX / TILE_SIZE), gridY = Math.floor(mouseY / TILE_SIZE);
            const selectedItem = player.inventory[selectedHotbarSlot];

            if (gridX < 0 || gridY < 0 || gridX >= WORLD_WIDTH || gridY >= WORLD_HEIGHT) return;
            const tile = world[gridX][gridY];

            // --- Continuous Logic (Holding Mouse) ---
            if (isContinuous) {
                // If holding Left Click, ONLY break player-placed blocks
                if (!isRightClick) {
                    if (tile === TILE_TYPES.WOOD_BLOCK) {
                        addItemToInventory(ITEM_TYPES.WOOD, 1);
                        world[gridX][gridY] = TILE_TYPES.EMPTY;
                        player.attackCooldown = 0.15; // Fast break
                        return;
                    } else if (tile === TILE_TYPES.STONE_BLOCK) {
                        addItemToInventory(ITEM_TYPES.STONE, 1);
                        world[gridX][gridY] = TILE_TYPES.EMPTY;
                        player.attackCooldown = 0.15;
                        return;
                    } else {
                        // Do NOT break trees/rocks/others continuously
                        return;
                    }
                }
                
                // If holding Right Click, place blocks
                if (isRightClick) {
                     if (tile === TILE_TYPES.EMPTY && selectedItem) {
                         const isPlaceable = [ITEM_TYPES.WOOD, ITEM_TYPES.STONE].some(it => it.id === selectedItem.type.id);
                         if (isPlaceable) {
                             // Check collision
                             let isOccupied = false;
                             for (const e of entities) {
                                 if (Math.floor(e.x / TILE_SIZE) === gridX && Math.floor(e.y / TILE_SIZE) === gridY) { isOccupied = true; break; }
                             }
                             if(Math.floor(player.x / TILE_SIZE) === gridX && Math.floor(player.y / TILE_SIZE) === gridY) isOccupied = true;

                             if (!isOccupied) {
                                 if (selectedItem.type === ITEM_TYPES.WOOD && countItems(ITEM_TYPES.WOOD) > 0) { 
                                     world[gridX][gridY] = TILE_TYPES.WOOD_BLOCK; removeItemFromInventory(player.inventory, ITEM_TYPES.WOOD, 1); 
                                 } else if (selectedItem.type === ITEM_TYPES.STONE && countItems(ITEM_TYPES.STONE) > 0) { 
                                     world[gridX][gridY] = TILE_TYPES.STONE_BLOCK; removeItemFromInventory(player.inventory, ITEM_TYPES.STONE, 1); 
                                 }
                             }
                         }
                     }
                     return;
                }
            }

            // --- Single Click Logic (Below this line runs only on click) ---

            // Check for placed object interaction first
            for (const obj of placedObjects) {
                 if (Math.hypot(mouseX - obj.x, mouseY - obj.y) < TILE_SIZE * 0.75) {
                    if (obj.type === 'DOOR') {
                        obj.isOpen = !obj.isOpen;
                        player.attackCooldown = 0.2;
                        return;
                    }
                    if (obj.type === 'CHEST') {
                        toggleChestScreen(obj);
                        return;
                    }
                     if (obj.type === 'BED') {
                        useBed(obj);
                        return;
                    }
                    if (obj.type === 'CAMPFIRE' && selectedItem && selectedItem.type === ITEM_TYPES.WOOD) {
                         if (obj.fuel < MAX_CAMPFIRE_FUEL) {
                            obj.fuel = Math.min(MAX_CAMPFIRE_FUEL, obj.fuel + CAMPFIRE_FUEL_PER_WOOD);
                            removeItemFromInventory(player.inventory, ITEM_TYPES.WOOD, 1);
                            showNotification("Вы подбросили дров в костер.");
                            player.attackCooldown = 0.3;
                        } else {
                            showNotification("В костре достаточно топлива.");
                        }
                        return; 
                    }
                 }
            }


            if (selectedItem) {
                if (selectedItem.type === ITEM_TYPES.MENTAL_SALVE) { player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + 50); removeItemFromInventory(player.inventory, ITEM_TYPES.MENTAL_SALVE, 1); player.attackCooldown = 0.5; return; }
                if (selectedItem.type === ITEM_TYPES.BERRY) { 
                    player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + 20);
                    player.shield = Math.min(player.maxShield, player.shield + 5);
                    removeItemFromInventory(player.inventory, ITEM_TYPES.BERRY, 1);
                    player.attackCooldown = 0.3;
                    return;
                }
                if (selectedItem.type === ITEM_TYPES.MYSTERIOUS_ARTIFACT) {
                    player.shield = player.maxShield;
                    showNotification("Вы чувствуете, как магическая энергия окутывает вас щитом!");
                    removeItemFromInventory(player.inventory, ITEM_TYPES.MYSTERIOUS_ARTIFACT, 1);
                    player.attackCooldown = 1;
                    return;
                }

                if (selectedItem.type === ITEM_TYPES.DESPAIR_CRYSTAL) {
                    let nearestAngel = null, minDist = Infinity;
                    entities.forEach(e => { if (e && e.type === ENTITY_TYPES.ANGEL) { const dist = Math.hypot(player.x - e.x, player.y - e.y); if (dist < minDist) { minDist = dist; nearestAngel = e; } } });
                    if (nearestAngel) { player.x = nearestAngel.x; player.y = nearestAngel.y; removeItemFromInventory(player.inventory, ITEM_TYPES.DESPAIR_CRYSTAL, 1); } 
                    else { showNotification("Поблизости нет ангелов, чтобы услышать твой зов."); }
                    player.attackCooldown = 1; return;
                }
                if (selectedItem.type === ITEM_TYPES.SLEEPING_BAG) { startSleepAnimation(); return; }
                if (selectedItem.type === ITEM_TYPES.SAKURA_PETAL) { spawnEntity(ENTITY_TYPES.HUMAN, player.x, player.y + TILE_SIZE * 1.5); removeItemFromInventory(player.inventory, ITEM_TYPES.SAKURA_PETAL, 1); player.attackCooldown = 0.5; return; }
            }
            
            let didAttack = false;
            const toolType = selectedItem?.type.id;
             if (toolType && (toolType.includes('SICKLE'))) {
                let sickleDamage = 1.5; // Half of base sword (3)
                let knockbackForce = 125; // Half of base sword (250)
                let range = TILE_SIZE * 1.2;
                if(toolType === 'FIRE_SICKLE') { 
                    sickleDamage = 12.5; // Half of fire sword (25)
                    knockbackForce = 200; // Half of fire sword (400)
                }
                
                entities.forEach(e => { 
                    if (!e) return;
                    if (Math.hypot(e.x - mouseX, e.y - mouseY) < range) {
                        e.health -= sickleDamage; e.lastDamageSource = 'player'; e.hitTimer = 0.2;
                        const angle = Math.atan2(e.y - player.y, e.x - player.x);
                        e.knockback.x = Math.cos(angle) * knockbackForce; e.knockback.y = Math.sin(angle) * knockbackForce;
                        didAttack = true;
                        if (e.health > 0) { 
                            if (e.type === ENTITY_TYPES.HUMAN && !e.isBoss) { e.aggressive = true; e.aggressionTimer = 30; } 
                            else if (e.type === ENTITY_TYPES.ANGEL) { damagePlayer(10); } 
                        }
                    }
                });
                if (didAttack) { player.attackCooldown = 0.5; damageItem(selectedHotbarSlot); return; }
            }
            if (toolType && toolType.includes('SWORD')) {
                let swordDamage = 3, knockbackForce = 250, range = TILE_SIZE * 1.2;
                if(toolType === 'STONE_SWORD') { swordDamage = 5; knockbackForce = 300; }
                if(toolType === 'FIRE_SWORD') { swordDamage = 25; knockbackForce = 400; range = TILE_SIZE * 1.5; }
                
                entities.forEach(e => { 
                    if (!e) return;
                    if (Math.hypot(e.x - mouseX, e.y - mouseY) < range) {
                        e.health -= swordDamage; e.lastDamageSource = 'player'; e.hitTimer = 0.2;
                        const angle = Math.atan2(e.y - player.y, e.x - player.x);
                        e.knockback.x = Math.cos(angle) * knockbackForce; e.knockback.y = Math.sin(angle) * knockbackForce;
                        didAttack = true;
                        if (e.health > 0) { 
                            if (e.type === ENTITY_TYPES.HUMAN && !e.isBoss) { e.aggressive = true; e.aggressionTimer = 30; } 
                            else if (e.type === ENTITY_TYPES.ANGEL) { damagePlayer(10); } 
                        }
                    }
                });
                if (didAttack) { player.attackCooldown = 0.5; damageItem(selectedHotbarSlot); return; }
            }

            
            if (tile === TILE_TYPES.GRASS_TUFT) {
                world[gridX][gridY] = TILE_TYPES.EMPTY;
                addItemToInventory(ITEM_TYPES.WITHERED_GRASS, 1 + Math.floor(Math.random() * 2)); // 1-2 grass
                player.attackCooldown = 0.3;
                return;
            }
            if (tile === TILE_TYPES.BERRY_BUSH) {
                if (selectedItem && (selectedItem.type.id === 'SICKLE' || selectedItem.type.id === 'FIRE_SICKLE')) {
                    const bush = growableObjects.find(b => b.x === gridX && b.y === gridY);
                    if (bush && bush.growth >= BERRY_GROWTH_TIME) {
                        addItemToInventory(ITEM_TYPES.BERRY, 2 + Math.floor(Math.random() * 2)); // 2-3 berries
                        bush.growth = 0; // Reset growth
                        damageItem(selectedHotbarSlot);
                        player.attackCooldown = 0.4;
                    } else {
                        showNotification("Здесь пока нет ягод.");
                    }
                } else {
                    showNotification("Нужен серп, чтобы собрать это.");
                }
                return;
            }

            if (tile === TILE_TYPES.ARTIFACT_BOX) {
                world[gridX][gridY] = TILE_TYPES.EMPTY;
                const drop = Math.random() < 0.75 ? ITEM_TYPES.TECHNOLOGY_SHARD : ITEM_TYPES.ANCIENT_CIRCUIT;
                addItemToInventory(drop, 1); showNotification(`+1 ${drop.name}`);
                player.attackCooldown = 0.3;
            }
            else {
                let usedTool = false;
                if (isPlayerPlaced(tile)) { 
                    if (tile === TILE_TYPES.WOOD_BLOCK) addItemToInventory(ITEM_TYPES.WOOD, 1);
                    else if (tile === TILE_TYPES.STONE_BLOCK) addItemToInventory(ITEM_TYPES.STONE, 1);
                    world[gridX][gridY] = TILE_TYPES.EMPTY;
                } else if (selectedItem) {
                    const toolPower = selectedItem.type.id.includes('STONE') ? 2 : (selectedItem.type.id.includes('FIRE') ? 5 : 1);
                    if ((tile === TILE_TYPES.TREE || tile === TILE_TYPES.BIRCH || tile === TILE_TYPES.OAK || tile === TILE_TYPES.SAKURA) && toolType.includes('AXE')) {
                         if (tile === TILE_TYPES.TREE) addItemToInventory(ITEM_TYPES.WOOD, 1 * toolPower);
                         else if (tile === TILE_TYPES.BIRCH) addItemToInventory(ITEM_TYPES.WOOD, 2 * toolPower); 
                         else if (tile === TILE_TYPES.OAK) { addItemToInventory(ITEM_TYPES.WOOD, 1 * toolPower); if (Math.random() < 0.5) addItemToInventory(ITEM_TYPES.ACORN, 1); }
                         else if (tile === TILE_TYPES.SAKURA) { addItemToInventory(ITEM_TYPES.WOOD, 1 * toolPower); addItemToInventory(ITEM_TYPES.SAKURA_PETAL, 1 * toolPower); }
                         world[gridX][gridY] = TILE_TYPES.EMPTY; usedTool = true;
                    } 
                    else if (tile === TILE_TYPES.ROCK && toolType.includes('PICKAXE')) { 
                        world[gridX][gridY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.STONE, 1 * toolPower); usedTool = true;
                    } 
                    else if (tile === TILE_TYPES.EMPTY) {
                        const isPlaceable = [ITEM_TYPES.WOOD, ITEM_TYPES.STONE, ITEM_TYPES.DOOR, ITEM_TYPES.CHEST, ITEM_TYPES.BED, ITEM_TYPES.CAMPFIRE].some(it => it.id === selectedItem.type.id);
                        if (isPlaceable) {
                            let isOccupied = false;
                            for (const e of entities) {
                                if (Math.floor(e.x / TILE_SIZE) === gridX && Math.floor(e.y / TILE_SIZE) === gridY) {
                                    isOccupied = true;
                                    break;
                                }
                            }
                            if (isOccupied) {
                                showNotification("Нельзя строить на существе!");
                                return;
                            }
                        }
                        const newObjX = gridX * TILE_SIZE + TILE_SIZE / 2;
                        const newObjY = gridY * TILE_SIZE + TILE_SIZE / 2;
                        if (selectedItem.type === ITEM_TYPES.WOOD && countItems(ITEM_TYPES.WOOD) > 0) { world[gridX][gridY] = TILE_TYPES.WOOD_BLOCK; removeItemFromInventory(player.inventory, ITEM_TYPES.WOOD, 1); } 
                        else if (selectedItem.type === ITEM_TYPES.STONE && countItems(ITEM_TYPES.STONE) > 0) { world[gridX][gridY] = TILE_TYPES.STONE_BLOCK; removeItemFromInventory(player.inventory, ITEM_TYPES.STONE, 1); }
                        else if (selectedItem.type === ITEM_TYPES.CAMPFIRE && countItems(ITEM_TYPES.CAMPFIRE) > 0) {
                            const tooClose = placedObjects.some(obj => obj.type === 'CAMPFIRE' && Math.hypot(newObjX - obj.x, newObjY - obj.y) < CAMPFIRE_PLACEMENT_RANGE);
                            if (tooClose) { showNotification("Слишком близко к другому костру!"); } 
                            else { placedObjects.push({ type: 'CAMPFIRE', x: newObjX, y: newObjY, fuel: CAMPFIRE_FUEL_PER_WOOD }); removeItemFromInventory(player.inventory, ITEM_TYPES.CAMPFIRE, 1); }
                        }
                        else if (selectedItem.type === ITEM_TYPES.DOOR && countItems(ITEM_TYPES.DOOR) > 0) {
                            placedObjects.push({ type: 'DOOR', x: newObjX, y: newObjY, isOpen: false });
                            removeItemFromInventory(player.inventory, ITEM_TYPES.DOOR, 1);
                        }
                        else if (selectedItem.type === ITEM_TYPES.CHEST && countItems(ITEM_TYPES.CHEST) > 0) {
                             placedObjects.push({ type: 'CHEST', x: newObjX, y: newObjY, inventory: Array(15).fill(null) });
                             removeItemFromInventory(player.inventory, ITEM_TYPES.CHEST, 1);
                        }
                         else if (selectedItem.type === ITEM_TYPES.BED && countItems(ITEM_TYPES.BED) > 0) {
                             placedObjects.push({ type: 'BED', x: newObjX, y: newObjY, uses: 3 });
                             removeItemFromInventory(player.inventory, ITEM_TYPES.BED, 1);
                        }
                    }
                }
                if (usedTool) { damageItem(selectedHotbarSlot); }
            }
        }
        
        // --- Controls and UI ---
        
        function toggleHandbook() {
            if (gameState === 'game_over' || inventoryScreen.style.display === 'flex' || chestScreen.style.display === 'flex' || gameState === 'sleeping') return;
            const isOpening = handbookScreen.style.display === 'none';
            if (isOpening) {
                gameState = 'paused';
                handbookScreen.style.display = 'flex';
                populateHandbook(Object.keys(HANDBOOK_DATA)[0]);
            } else {
                gameState = 'playing';
                handbookScreen.style.display = 'none';
            }
        }

        function populateHandbook(activeCategory) {
            const tabsContainer = document.getElementById('handbook-tabs');
            const contentContainer = document.getElementById('handbook-content');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';

            Object.keys(HANDBOOK_DATA).forEach(category => {
                const tab = document.createElement('div');
                tab.className = 'handbook-tab';
                tab.textContent = category;
                if (category === activeCategory) {
                    tab.classList.add('active');
                }
                tab.addEventListener('click', () => populateHandbook(category));
                tabsContainer.appendChild(tab);
            });

            const categoryData = HANDBOOK_DATA[activeCategory];
            for (const itemName in categoryData) {
                const itemData = categoryData[itemName];
                const entry = document.createElement('div');
                entry.className = 'handbook-entry';

                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = iconCanvas.height = 48;
                iconCanvas.className = 'handbook-entry-icon';
                const iconCtx = iconCanvas.getContext('2d');
                iconCtx.imageSmoothingEnabled = false;
                drawPixelArtOnCtx(iconCtx, 0, 0, 48, itemData.art);

                const textDiv = document.createElement('div');
                textDiv.className = 'handbook-entry-text';
                textDiv.innerHTML = `<h3>${itemName}</h3><p>${itemData.description}</p>`;
                
                entry.appendChild(iconCanvas);
                entry.appendChild(textDiv);
                contentContainer.appendChild(entry);
            }
        }
        
        // --- Character Select Logic ---
        function populateCharacterCards() {
            const container = document.getElementById('character-carousel');
            container.innerHTML = '';
            CHARACTERS.forEach((char, index) => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.dataset.charId = char.id;
                card.dataset.charIndex = index;
                card.innerHTML = `
                    <h3>${char.name}</h3>
                    <div class="char-icon"></div>
                `;
                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = iconCanvas.height = 80;
                const iconCtx = iconCanvas.getContext('2d');
                iconCtx.imageSmoothingEnabled = false;
                drawPixelArtOnCtx(iconCtx, 0, 0, 80, char.art);
                card.querySelector('.char-icon').appendChild(iconCanvas);
                
                card.addEventListener('click', () => {
                     scrollToCharacter(index);
                });
                
                container.appendChild(card);
            });
            updateCharacterSelectionVisuals(0);
        }
        
        function scrollToCharacter(index) {
             const container = document.getElementById('character-carousel');
             const cards = container.querySelectorAll('.character-card');
             if (index < 0) index = 0;
             if (index >= cards.length) index = cards.length - 1;
             
             const card = cards[index];
             const containerWidth = container.offsetWidth;
             const cardWidth = card.offsetWidth;
             // Calculate center position
             const scrollPos = card.offsetLeft - (containerWidth / 2) + (cardWidth / 2);
             
             container.scrollTo({ left: scrollPos, behavior: 'smooth' });
        }

        function setupCarouselObserver() {
            const carousel = document.getElementById('character-carousel');
            const cards = carousel.querySelectorAll('.character-card');
            
            // Add scroll listener for manual tracking
            carousel.addEventListener('scroll', () => {
                 let closestCard = null;
                 let minDiff = Infinity;
                 const center = carousel.scrollLeft + carousel.offsetWidth / 2;
                 
                 cards.forEach((card, index) => {
                     const cardCenter = card.offsetLeft + card.offsetWidth / 2;
                     const diff = Math.abs(center - cardCenter);
                     if (diff < minDiff) {
                         minDiff = diff;
                         closestCard = index;
                     }
                 });
                 
                 if (closestCard !== null && closestCard !== currentCharIndex) {
                     updateCharacterSelectionVisuals(closestCard);
                 }
            });
        }

        function updateCharacterSelectionVisuals(newIndex) {
            currentCharIndex = newIndex;
            const carousel = document.getElementById('character-carousel');
            const cards = carousel.querySelectorAll('.character-card');

            cards.forEach((card, index) => {
                card.classList.toggle('selected', index === newIndex);
            });

            const details = document.getElementById('character-details');
            const char = CHARACTERS[currentCharIndex];
            if (!char) return;
            selectedCharacterId = char.id;
            document.getElementById('char-name').textContent = char.name;
            document.getElementById('char-desc').textContent = char.description;
        }
        
        document.getElementById('prev-char').addEventListener('click', () => scrollToCharacter(currentCharIndex - 1));
        document.getElementById('next-char').addEventListener('click', () => scrollToCharacter(currentCharIndex + 1));
        
        // --- Event Listeners ---
        window.addEventListener('resize', () => {
             resizeCanvas();
        });
        window.addEventListener('keydown', (e) => {
            if (gameState === 'start' || gameState === 'game_over') return;
            const code = e.code; // Use code for layout independence
            
            if (code === 'Escape') {
                if (inventoryScreen.style.display === 'flex') toggleInventory();
                if (handbookScreen.style.display === 'flex') toggleHandbook();
                if (chestScreen.style.display === 'flex') toggleChestScreen();
                return;
            }

            if (gameState === 'paused' || gameState === 'sleeping') return;

            keys[code] = true;
            if (e.key >= '1' && e.key <= '5') selectedHotbarSlot = parseInt(e.key) - 1;
            if (code === 'KeyE' || code === 'KeyI') {
                toggleInventory();
            }
        });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        window.addEventListener('mousemove', (e) => {
            // Adjust mouse pos relative to canvas to handle any CSS scaling if present
            const rect = canvas.getBoundingClientRect();
            mousePos.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mousePos.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        });

        canvas.addEventListener('mousedown', (e) => {
             if (e.button === 0) {
                 isMouseDown = true;
                 handleInteraction(e.clientX, e.clientY); // Initial click
             } else if (e.button === 2) { // Right click
                 isRightMouseDown = true;
                 handleInteraction(e.clientX, e.clientY);
             }
        });
        window.addEventListener('mouseup', () => { isMouseDown = false; isRightMouseDown = false; });
        window.addEventListener('contextmenu', (e) => e.preventDefault()); // Disable context menu for right click

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInteraction(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        
        startButton.addEventListener('click', () => { 
            startScreen.style.display = 'none'; 
            characterSelectScreen.style.display = 'flex';
            populateCharacterCards();
            setTimeout(setupCarouselObserver, 100); 
        });
        restartButton.addEventListener('click', () => { 
            location.reload();
        });
        confirmCharButton.addEventListener('click', () => {
            characterSelectScreen.style.display = 'none';
            initGame();
        });
        backToMainMenuButton.addEventListener('click', () => {
             characterSelectScreen.style.display = 'none';
             startScreen.style.display = 'flex';
        });
        
        prequelButton.addEventListener('click', () => { startScreen.style.display = 'none'; prequelScreen.style.display = 'flex'; });
        backFromPrequelButton.addEventListener('click', () => { prequelScreen.style.display = 'none'; startScreen.style.display = 'flex'; });
        handbookButton.addEventListener('click', toggleHandbook);
        handbookCloseButton.addEventListener('click', toggleHandbook);

        const continueButton = document.getElementById('continue-button');
        if (localStorage.getItem(SAVE_KEY)) {
            continueButton.style.display = 'inline-block';
        }
        continueButton.addEventListener('click', () => {
            if (!loadGame()) {
                startScreen.style.display = 'none'; 
                characterSelectScreen.style.display = 'flex';
                populateCharacterCards();
                setTimeout(setupCarouselObserver, 100);
            }
        });
        window.addEventListener('beforeunload', (e) => {
            saveGame();
        });

        inventoryScreen.addEventListener('click', (e) => {
            if (e.target === inventoryScreen) { 
                toggleInventory();
            }
        });
        chestScreen.addEventListener('click', (e) => {
             if (e.target === chestScreen) { 
                toggleChestScreen();
            }
        });

        const inventoryButtonMobile = document.getElementById('inventory-button-mobile');
        inventoryButtonMobile.addEventListener('click', toggleInventory);

        let draggedItem = { index: null, from: null };
        
        function handleDragStart(e) {
            const slot = e.target.closest('.hotbar-slot');
            if (!slot || slot.classList.contains('drop-slot')) return;
            draggedItem.index = parseInt(slot.dataset.slotIndex);
            draggedItem.from = slot.dataset.inventory;
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => slot.classList.add('dragging'), 0);
        }

        function handleDragEnd(e) {
            const slot = e.target.closest('.hotbar-slot');
            if(slot) slot.classList.remove('dragging');
            draggedItem.index = null;
            draggedItem.from = null;
        }
        
        function handleDragOver(e) { e.preventDefault(); }

        function handleDrop(e) {
            e.preventDefault();
            const targetSlot = e.target.closest('.hotbar-slot, .inventory-slot');
            
            if (draggedItem.index === null || !targetSlot) return;

            const toIndex = parseInt(targetSlot.dataset.slotIndex);
            const toInventoryType = targetSlot.dataset.inventory;
            
            const fromInventory = (draggedItem.from === 'player') ? player.inventory : activeChest.inventory;
            const toInventory = (toInventoryType === 'player') ? player.inventory : activeChest.inventory;

            if (toInventoryType === 'player' && toIndex === player.inventory.length - 1) {
                const itemToDrop = fromInventory[draggedItem.index];
                if (itemToDrop) {
                    droppedItems.push({ x: player.x, y: player.y, item: { ...itemToDrop } });
                    fromInventory[draggedItem.index] = null;
                    player.pickupCooldown = 1.0; 
                }
            } else {
                if (!toInventory || toIndex >= toInventory.length) return;
                
                if(draggedItem.from === toInventoryType && draggedItem.index === toIndex) return;

                const temp = fromInventory[draggedItem.index];
                fromInventory[draggedItem.index] = toInventory[toIndex];
                toInventory[toIndex] = temp;
            }
            
            if (inventoryScreen.style.display === 'flex') updateInventoryScreen();
            else if (chestScreen.style.display === 'flex') updateChestScreen();
            updateUI();
        }
        
        document.getElementById('hotbar').addEventListener('click', (e) => {
            const slot = e.target.closest('.hotbar-slot');
            if (slot) selectedHotbarSlot = parseInt(slot.dataset.slotIndex);
        });
        
        const setupDragListeners = (container) => {
            container.addEventListener('dragstart', handleDragStart);
            container.addEventListener('dragend', handleDragEnd);
            container.addEventListener('dragover', handleDragOver);
            container.addEventListener('drop', handleDrop);
        };
        setupDragListeners(document.getElementById('inventory-screen'));
        setupDragListeners(document.getElementById('chest-screen'));
        setupDragListeners(document.getElementById('hotbar'));

        function isTouchDevice() { return 'ontouchstart' in window || navigator.maxTouchPoints > 0; }
        if (isTouchDevice()) {
            joystickContainer.style.display = 'block';
            inventoryButtonMobile.style.display = 'flex';
            joystickContainer.innerHTML = `<div id="joystick-handle"></div>`;
            joystickContainer.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; }, { passive: false });
            joystickContainer.addEventListener('touchmove', (e) => {
                if (joystick.active) e.preventDefault(); 
                if (!joystick.active) return;
                const touch = e.touches[0];
                const rect = joystickContainer.getBoundingClientRect();
                const joySize = rect.width, maxDist = joySize / 2.5;
                const joyX = rect.left + joySize / 2, joyY = rect.top + joySize / 2;
                let dx = touch.clientX - joyX, dy = touch.clientY - joyY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }
                
                document.getElementById('joystick-handle').style.transform = `translate(${dx}px, ${dy}px)`;
                
                if (dist > 5) {
                    joystick.dx = dx / maxDist;
                    joystick.dy = dy / maxDist;
                } else {
                    joystick.dx = 0;
                    joystick.dy = 0;
                }
            }, { passive: false });

            window.addEventListener('touchend', (e) => {
                let joyTouchEnded = true; 
                for(let i = 0; i < e.touches.length; i++) {
                     const touch = e.touches[i];
                     const rect = joystickContainer.getBoundingClientRect();
                     if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                        touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                         joyTouchEnded = false;
                         break;
                     }
                }
                if(joyTouchEnded) {
                    joystick.active = false; joystick.dx = 0; joystick.dy = 0;
                    document.getElementById('joystick-handle').style.transform = 'translate(0px, 0px)';
                }
            });
            
            let touchDraggedSlot = null;
            let touchDragGhost = null;
            const inventoryContainer = document.getElementById('inventory-screen');
            const chestContainer = document.getElementById('chest-screen');
            
            const touchStartHandler = (e) => {
                 const slot = e.target.closest('.hotbar-slot');
                 if (slot && !slot.classList.contains('drop-slot')) {
                    const fromInventoryType = slot.dataset.inventory;
                    const index = parseInt(slot.dataset.slotIndex);
                    const inventory = fromInventoryType === 'player' ? player.inventory : activeChest.inventory;
                     if(inventory && inventory[index]) {
                         touchDraggedSlot = slot;
                         slot.style.opacity = '0.5';

                         touchDragGhost = slot.cloneNode(true);
                         touchDragGhost.style.position = 'absolute';
                         touchDragGhost.style.zIndex = '1000';
                         touchDragGhost.style.pointerEvents = 'none';
                         touchDragGhost.style.width = slot.offsetWidth + 'px';
                         touchDragGhost.style.height = slot.offsetHeight + 'px';
                         touchDragGhost.style.opacity = '0.8';
                         document.body.appendChild(touchDragGhost);
                         const touch = e.touches[0];
                         touchDragGhost.style.left = (touch.clientX - slot.offsetWidth / 2) + 'px';
                         touchDragGhost.style.top = (touch.clientY - slot.offsetHeight / 2) + 'px';
                     }
                 }
            };

            const touchEndHandler = (e) => {
                if (touchDraggedSlot) {
                    touchDraggedSlot.style.opacity = '1';
                    const touch = e.changedTouches[0];
                    const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                    const targetSlot = elementUnder ? elementUnder.closest('.hotbar-slot') : null;
                    
                    if (targetSlot && targetSlot.dataset.slotIndex) {
                        const fromIndex = parseInt(touchDraggedSlot.dataset.slotIndex);
                        const fromInventoryType = touchDraggedSlot.dataset.inventory;
                        const toIndex = parseInt(targetSlot.dataset.slotIndex);
                        const toInventoryType = targetSlot.dataset.inventory;

                        const fromInventory = fromInventoryType === 'player' ? player.inventory : activeChest.inventory;
                        const toInventory = toInventoryType === 'player' ? player.inventory : activeChest.inventory;

                        if (toInventoryType === 'player' && toIndex === player.inventory.length - 1) { 
                            const itemToDrop = fromInventory[fromIndex];
                            if (itemToDrop) {
                                 droppedItems.push({ x: player.x, y: player.y, item: { ...itemToDrop } });
                                 fromInventory[fromIndex] = null;
                                 player.pickupCooldown = 1.0; 
                            }
                        } else { 
                            if (toInventory && toIndex < toInventory.length) {
                                const temp = fromInventory[fromIndex];
                                fromInventory[fromIndex] = toInventory[toIndex];
                                toInventory[toIndex] = temp;
                            }
                        }
                    }
                    
                    if(inventoryContainer.style.display === 'flex') updateInventoryScreen();
                    if(chestContainer.style.display === 'flex') updateChestScreen();
                }
                if (touchDragGhost) {
                    touchDragGhost.remove();
                    touchDragGhost = null;
                }
                touchDraggedSlot = null;
            };

            const touchMoveHandler = (e) => {
                if (touchDraggedSlot && touchDragGhost) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    touchDragGhost.style.left = (touch.clientX - touchDragGhost.offsetWidth / 2) + 'px';
                    touchDragGhost.style.top = (touch.clientY - touchDragGhost.offsetHeight / 2) + 'px';
                }
            };
            
            const setupTouchListeners = (container) => {
                container.addEventListener('touchstart', touchStartHandler, {passive: false});
                container.addEventListener('touchend', touchEndHandler);
                container.addEventListener('touchmove', touchMoveHandler, { passive: false });
            };
            
            setupTouchListeners(inventoryContainer);
            setupTouchListeners(chestContainer);
        }
    </script>
</body>
</html>
