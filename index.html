<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LIMBO</title>
    <style>
        :root {
            --ui-bg: rgba(20, 20, 20, 0.75);
            --border-color: rgba(120, 120, 120, 0.5);
            --highlight-color: #fff;
            --un-craftable-color: #ff5555;
            --slot-bg: #2c2c2c;
            --slot-size: clamp(40px, 10vw, 60px);
            --ui-padding: clamp(10px, 3vw, 20px);
            --ui-radius: 10px;
        }
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            image-rendering: pixelated;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #111;
            cursor: crosshair;
            transition: filter 1.5s linear;
        }

        /* --- UI Поверх игры --- */
        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: var(--ui-padding);
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
        }
        .game-ui-element {
            background-color: var(--ui-bg);
            backdrop-filter: blur(8px);
            border-radius: var(--ui-radius);
            border: 2px solid var(--border-color);
            padding: 8px 12px;
            box-sizing: border-box;
            pointer-events: auto;
        }
        #mental-health-bar-container {
            flex-grow: 1;
            max-width: 350px;
            padding: 6px;
        }
        #mental-health-bar {
            width: 100%;
            height: 16px;
            background-color: var(--highlight-color);
            transition: width 0.5s;
            border-radius: 5px;
        }
        #clock-container {
            text-align: center;
            font-size: clamp(14px, 4vw, 16px);
            flex-shrink: 0; /* Prevent shrinking */
        }
        #handbook-button {
             width: 42px;
             height: 42px;
             font-size: 24px;
             font-weight: bold;
             padding: 0;
             cursor: pointer;
             flex-shrink: 0;
             line-height: 40px;
             text-align: center;
        }

        #bottom-ui {
            position: absolute;
            bottom: var(--ui-padding);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
        }
        #hotbar {
            display: flex;
            gap: 8px;
            background-color: var(--ui-bg);
            backdrop-filter: blur(8px);
            padding: 8px;
            border-radius: var(--ui-radius);
            border: 2px solid var(--border-color);
            pointer-events: auto;
        }
        .hotbar-slot {
            width: var(--slot-size);
            height: var(--slot-size);
            border: 2px solid var(--border-color);
            background-color: var(--slot-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            user-select: none;
            border-radius: 5px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .hotbar-slot.selected {
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            transform: scale(1.1);
        }
        .item-icon {
            width: 100%;
            height: 100%;
            pointer-events: none; /* Make sure events go to the slot */
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: bold;
            text-shadow: 2px 2px 3px black;
            pointer-events: none;
        }
        .dragging {
            opacity: 0.5;
        }
        
        /* --- Экраны --- */
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
        }
        .screen-overlay h1 { font-size: clamp(32px, 10vw, 48px); }
        .screen-overlay p { max-width: 600px; line-height: 1.5; padding: 0 20px; font-size: clamp(14px, 4vw, 16px); }
        .screen-overlay button {
            background: var(--slot-bg); color: #fff; border: 2px solid var(--border-color); padding: 12px 24px;
            font-family: inherit; font-size: clamp(16px, 5vw, 18px); cursor: pointer; margin-top: 20px; border-radius: var(--ui-radius);
        }
        .screen-overlay button:hover { border-color: var(--highlight-color); background-color: #333; }

        /* --- Инвентарь и Крафт --- */
        #inventory-screen {
            flex-direction: row;
            flex-wrap: nowrap; /* Prevent wrapping */
            gap: 20px;
            padding: var(--ui-padding);
            align-items: stretch; /* Make panels same height */
            justify-content: center;
            z-index: 200; /* Поднимаем выше джойстика */
        }
        .inventory-panel {
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid var(--border-color);
            border-radius: var(--ui-radius);
            padding: 15px;
            max-height: calc(100vh - 2 * var(--ui-padding));
            display: flex;
            flex-direction: column;
            width: clamp(280px, 40vw, 400px);
            max-width: 90vw;
            box-sizing: border-box;
        }
        
        #crafting-panel h2, #inventory-panel h2 {
            margin-top: 0; text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px;
        }

        #recipe-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-shrink: 1; }
        #recipe-list li {
            padding: 10px; border-bottom: 1px solid #333; cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border-radius: 5px;
        }
        #recipe-list li:hover { background-color: #333; }
        #recipe-list li.selected { background-color: #444; }
        #recipe-list li.un-craftable {
            color: #aaa;
            cursor: not-allowed;
        }
        #recipe-list li.un-craftable:hover {
            background-color: transparent;
        }
        #crafting-details ul li.needed-bad {
             color: var(--un-craftable-color) !important;
        }
        
        #crafting-details { margin-top: 15px; text-align: center; }
        #craft-button { width: 100%; margin-top: auto; padding: 12px;}
        #craft-button:disabled { background: #111; color: #555; border-color: #333; cursor: not-allowed;}
        
        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(var(--slot-size), 1fr));
            gap: 8px;
            overflow-y: auto;
        }
        
        /* Адаптивность для мобильных */
        @media (max-width: 768px) and (orientation: portrait), (max-height: 500px) {
            #inventory-screen {
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
            .inventory-panel {
                max-height: calc(50vh - 1.5 * var(--ui-padding));
                width: 90vw;
            }
        }
        
        /* --- Справочник --- */
        #handbook-panel {
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid var(--border-color);
            border-radius: var(--ui-radius);
            width: clamp(300px, 90vw, 800px);
            height: clamp(400px, 90vh, 600px);
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #handbook-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        #handbook-header h1 {
            margin: 0;
            font-size: clamp(24px, 6vw, 28px);
        }
        #handbook-close-button {
            background: none;
            border: none;
            color: #fff;
            font-size: 32px;
            cursor: pointer;
            padding: 0 10px;
        }
        #handbook-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        .handbook-tab {
            background: var(--slot-bg);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .handbook-tab:hover {
            background-color: #444;
        }
        .handbook-tab.active {
            background-color: #555;
            border-color: var(--highlight-color);
        }
        #handbook-content {
            overflow-y: auto;
            flex-grow: 1;
            padding-right: 10px; /* для скроллбара */
        }
        .handbook-entry {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            border-bottom: 1px solid #333;
        }
        .handbook-entry:last-child {
            border-bottom: none;
        }
        .handbook-entry-icon {
            width: 48px;
            height: 48px;
            flex-shrink: 0;
        }
        .handbook-entry-text h3 {
            margin: 0 0 5px 0;
            color: var(--highlight-color);
        }
         .handbook-entry-text p {
            margin: 0;
            font-size: 14px;
            color: #ccc;
            line-height: 1.4;
        }


        /* --- Джойстик и мобильные кнопки --- */
        #joystick-container {
            position: absolute;
            bottom: calc(var(--ui-padding) + var(--slot-size) + 20px);
            left: var(--ui-padding);
            width: clamp(100px, 20vw, 120px);
            height: clamp(100px, 20vw, 120px);
            background-color: rgba(80, 80, 80, 0.3);
            border-radius: 50%;
            display: none;
            z-index: 50;
        }
        #joystick-handle {
            position: absolute; width: 45%; height: 45%;
            background-color: rgba(200, 200, 200, 0.5); border-radius: 50%;
            left: 27.5%; top: 27.5%;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .mobile-ui-button {
            width: var(--slot-size);
            height: var(--slot-size);
            border: 2px solid var(--border-color);
            background-color: var(--ui-bg);
            display: none; /* Hide by default */
            justify-content: center;
            align-items: center;
            border-radius: var(--ui-radius);
            pointer-events: auto;
            cursor: pointer;
            backdrop-filter: blur(8px);
        }
        .mobile-ui-button:active { transform: scale(0.95); }
        .mobile-ui-button svg {
            width: 70%; height: 70%; fill: #fff;
        }
        
        /* --- Уведомления --- */
        #notification-container {
            position: absolute;
            top: calc(var(--ui-padding) * 2 + 50px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 250;
            pointer-events: none;
        }
        .notification-message {
            background-color: var(--ui-bg);
            color: #fff;
            padding: 10px 20px;
            border-radius: var(--ui-radius);
            border: 1px solid var(--border-color);
            animation: fadeOut 5s forwards;
            opacity: 1;
            font-size: clamp(12px, 3vw, 14px);
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

    </style>
</head>
<body>

    <div id="start-screen" class="screen-overlay">
        <h1>Тень и Свет</h1>
        <p>Используйте E или I, чтобы открыть инвентарь и меню крафта.</p>
        <button id="prequel-button">Предыстория</button>
        <button id="start-button">Начать выживание</button>
    </div>
    
    <div id="prequel-screen" class="screen-overlay" style="display: none;">
        <h1>Предыстория</h1>
        <p style="max-width: 600px; text-align: center;">ТЫ ЧЕЛОВЕК, КОТОРЫЙ НЕ ПОПАЛ НИ В РАЙ, НИ В АД И ОСТАЛСЯ В ЛИМБО СКИТАТЬСЯ ВЕЧНОСТЬ... или пока тебя не настигнет что-то хуже смерти.</p>
        <button id="back-from-prequel-button">Назад</button>
    </div>

    <div id="game-over-screen" class="screen-overlay" style="display: none;">
        <h1>Вы не можете умереть, но рассудок покинул вас и вы стали очередной тенью в этом месте</h1>
        <button id="restart-button">Попробовать снова</button>
    </div>
    
    <div id="handbook-screen" class="screen-overlay" style="display: none; z-index: 300;">
        <div id="handbook-panel">
            <div id="handbook-header">
                <h1>Справочник</h1>
                <button id="handbook-close-button">&times;</button>
            </div>
            <div id="handbook-tabs"></div>
            <div id="handbook-content"></div>
        </div>
    </div>

    <div id="inventory-screen" class="screen-overlay" style="display: none;">
        <div id="crafting-panel" class="inventory-panel">
            <h2>Крафт</h2>
            <ul id="recipe-list"></ul>
            <div id="crafting-details">
                <p>Выберите рецепт</p>
            </div>
            <button id="craft-button" disabled>Создать</button>
        </div>
        <div id="inventory-panel" class="inventory-panel">
            <h2>Инвентарь</h2>
            <div id="inventory-grid"></div>
        </div>
    </div>
    
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="notification-container"></div>
        <div id="top-bar">
            <div id="mental-health-bar-container" class="game-ui-element">
                <div id="mental-health-bar"></div>
            </div>
             <div style="display: flex; gap: 10px; align-items: flex-start;">
                <div id="clock-container" class="game-ui-element">
                    <div id="day-counter">День 1</div>
                    <div id="time-display">06:00</div>
                </div>
                <button id="handbook-button" class="game-ui-element">?</button>
            </div>
        </div>
        <div id="bottom-ui">
            <div id="hotbar"></div>
            <div id="inventory-button-mobile" class="mobile-ui-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z"/></svg>
            </div>
        </div>
        <div id="joystick-container"></div>
    </div>

    <script>
    // --- Инициализация ---
    const canvas = document.getElementById('game-canvas'); const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen'); const gameOverScreen = document.getElementById('game-over-screen');
    const startButton = document.getElementById('start-button'); const restartButton = document.getElementById('restart-button');
    const inventoryScreen = document.getElementById('inventory-screen'); const joystickContainer = document.getElementById('joystick-container');
    const prequelScreen = document.getElementById('prequel-screen');
    const prequelButton = document.getElementById('prequel-button');
    const backFromPrequelButton = document.getElementById('back-from-prequel-button');
    const handbookScreen = document.getElementById('handbook-screen');
    const handbookButton = document.getElementById('handbook-button');
    const handbookCloseButton = document.getElementById('handbook-close-button');


    const TILE_SIZE = 32, WORLD_WIDTH = 100, WORLD_HEIGHT = 100;
    const MENTAL_HEALTH_DRAIN_RATE = 0.5, ANGEL_HEAL_RADIUS = TILE_SIZE * 4, ANGEL_HEAL_RATE = 15, HUMAN_HEAL_RADIUS = TILE_SIZE * 3, HUMAN_HEAL_RATE = 5;
    const DAY_DURATION_SECONDS = 24 * 60; // 24 минуты
    const PLAYER_STUN_DURATION = 3; // Для капкана

    // --- Новые константы ---
    const CAMPFIRE_DURATION = 300; // 5 минут
    const CAMPFIRE_HEAL_RATE = 3; // mental health per second
    const CAMPFIRE_HEAL_RADIUS = TILE_SIZE * 3;
    const CAMPFIRE_LIGHT_RADIUS = TILE_SIZE * 5;
    const FLASHLIGHT_RANGE = TILE_SIZE * 8;
    const FLASHLIGHT_CONE_ANGLE = Math.PI / 4; // 45 градусов
    const FLASHLIGHT_DAMAGE = 10; // в секунду

    let player, world, entities, camera, joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0 };
    let placedObjects = []; // Для костров и т.д.
    let traps = []; // Для ловушек
    let projectiles = []; // Для снарядов боссов
    let mousePos = { x: 0, y: 0 };
    let selectedHotbarSlot = 0, keys = {}, gameState = 'start', lastTime = 0, gameTime = DAY_DURATION_SECONDS * 0.25; // Начать в 6 утра

    // --- Структуры данных ---
    const ITEM_TYPES = {
        WOOD: { id: 'WOOD', name: 'Дерево' }, STONE: { id: 'STONE', name: 'Камень' },
        AXE: { id: 'AXE', name: 'Топор' }, PICKAXE: { id: 'PICKAXE', name: 'Кирка' }, SWORD: { id: 'SWORD', name: 'Меч' },
        STONE_AXE: { id: 'STONE_AXE', name: 'Кам. топор' }, STONE_PICKAXE: { id: 'STONE_PICKAXE', name: 'Кам. кирка' },
        STONE_SWORD: { id: 'STONE_SWORD', name: 'Кам. меч' },
        FIRE_AXE: { id: 'FIRE_AXE', name: 'Огненный топор' }, FIRE_PICKAXE: { id: 'FIRE_PICKAXE', name: 'Огненная кирка' }, FIRE_SWORD: { id: 'FIRE_SWORD', name: 'Огненный меч' },
        DARK_ORB: { id: 'DARK_ORB', name: 'Шар Тьмы' }, MENTAL_SALVE: { id: 'MENTAL_SALVE', name: 'Целебная мазь' },
        ACORN: { id: 'ACORN', name: 'Жёлудь' },
        SAKURA_PETAL: { id: 'SAKURA_PETAL', name: 'Лепесток сакуры' },
        DESPAIR_CRYSTAL: { id: 'DESPAIR_CRYSTAL', name: 'Кристалл отчаянья' },
        SLEEPING_BAG: { id: 'SLEEPING_BAG', name: 'Спальник' },
        CAMPFIRE: { id: 'CAMPFIRE', name: 'Костёр' },
        FLASHLIGHT: { id: 'FLASHLIGHT', name: 'Фонарик' },
    };
    const TILE_TYPES = { EMPTY: 0, TREE: 1, ROCK: 2, WOOD_BLOCK: 4, STONE_BLOCK: 5, BIRCH: 6, OAK: 7, SAKURA: 8 };
    const ENTITY_TYPES = { SHADOW: 'SHADOW', ANGEL: 'ANGEL', HUMAN: 'HUMAN', MUTANT_HUMAN: 'MUTANT_HUMAN', ARCHANGEL: 'ARCHANGEL', DEMON: 'DEMON', FALSE_ANGEL: 'FALSE_ANGEL' };
    const RECIPES = [
        { output: { type: ITEM_TYPES.STONE_AXE, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 2 }, { type: ITEM_TYPES.STONE, count: 3 }] },
        { output: { type: ITEM_TYPES.STONE_PICKAXE, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 2 }, { type: ITEM_TYPES.STONE, count: 3 }] },
        { output: { type: ITEM_TYPES.STONE_SWORD, count: 1 }, ingredients: [{ type: ITEM_TYPES.WOOD, count: 1 }, { type: ITEM_TYPES.STONE, count: 2 }] },
        { output: { type: ITEM_TYPES.MENTAL_SALVE, count: 1 }, ingredients: [{ type: ITEM_TYPES.DARK_ORB, count: 1 }, { type: ITEM_TYPES.STONE, count: 5 }] },
        { output: { type: ITEM_TYPES.DESPAIR_CRYSTAL, count: 1 }, ingredients: [{ type: ITEM_TYPES.ACORN, count: 1 }, { type: ITEM_TYPES.DARK_ORB, count: 2 }, { type: ITEM_TYPES.WOOD, count: 10 }] },
        { output: { type: ITEM_TYPES.SLEEPING_BAG, count: 1 }, ingredients: [{ type: ITEM_TYPES.SAKURA_PETAL, count: 3 }, { type: ITEM_TYPES.WOOD, count: 1 }, { type: ITEM_TYPES.MENTAL_SALVE, count: 1 }] },
        { output: { type: ITEM_TYPES.CAMPFIRE, count: 1 }, ingredients: [{ type: ITEM_TYPES.STONE, count: 3 }, { type: ITEM_TYPES.WOOD, count: 3 }] },
        { output: { type: ITEM_TYPES.FLASHLIGHT, count: 1 }, ingredients: [{ type: ITEM_TYPES.DESPAIR_CRYSTAL, count: 1 }, { type: ITEM_TYPES.DARK_ORB, count: 3 }] },
    ];
    let selectedRecipe = null;

    // --- Графика ---
    const art = {
        player: [['#ccc', '#ccc'],['#888', '#888'],['#888', '#888'],['#444', '#444']],
        human: [['#f0d2a4', '#f0d2a4'], ['#3e84d4', '#3e84d4'], ['#3e84d4', '#3e84d4'], ['#5a3d24', '#5a3d24']],
        tree: [[null, '#292', '#292', null],['#292', '#3a3', '#3a3', '#292'],[null, '#643', '#643', null],[null, '#643', '#643', null]],
        birch: [[null, '#ddd', '#111', null],['#ddd', '#fff', '#111', '#ddd'],[null, '#eee', '#eee', null],[null, '#eee', '#eee', null]],
        oak: [[null, '#282', '#282', null],['#282', '#3a3', '#3a3', '#282'],[null, '#754', '#754', null],[null, '#754', '#754', null]],
        sakura: [[null, '#fbc', '#fbc', null],['#fbc', '#fce', '#fce', '#fbc'],[null, '#532', '#532', null],[null, '#532', '#532', null]],
        rock: [[null, '#888', null],['#aaa', '#888', '#aaa'],['#aaa', '#aaa', '#aaa']],
        shadow: (f) => [[null, f ? '#222' : '#111', null],[f ? '#333' : '#222', '#111', f ? '#333' : '#222'],[null, f ? '#222' : '#111', null]],
        angel: (f) => [[f ? '#fff' : '#eee', '#fff', f ? '#fff' : '#eee'],[null, '#ddd', null]],
        axe: [['#ccc', '#aaa', null],[null, '#643', '#ccc'],[null, '#643', null]],
        pickaxe: [['#ccc', '#ccc', '#ccc'],[null, '#643', null],[null, '#643', null]],
        sword: [[null, '#fff', null],[null, '#fff', null],[null, '#643', null]],
        wood_block: [['#965', '#854', '#965', '#854'],['#643', '#854', '#643', '#854'],['#965', '#854', '#965', '#854'],['#643', '#854', '#643', '#854']],
        stone_block: [['#aaa', '#aaa', '#999', '#888'],['#aaa', '#888', '#888', '#999'],['#999', '#888', '#777', '#777'],['#888', '#999', '#777', '#aaa']],
        stone_axe: [['#888', '#666', null],[null, '#643', '#888'],[null, '#643', null]],
        stone_pickaxe: [['#888', '#888', '#888'],[null, '#643', null],[null, '#643', null]],
        stone_sword: [[null, '#888', null],[null, '#888', null],[null, '#643', null]],
        dark_orb: [[null, '#201', null], ['#302', '#101', '#302'], [null, '#201', null]],
        mental_salve: [[null, '#afa', null], ['#9c9', '#dfd', '#9c9'], [null, '#afa', null]],
        acorn: [[null, '#864', null],['#864', '#a85', '#864'],[null, '#a85', null]],
        sakura_petal: [[null, '#fde', null], ['#fde', '#fbc', '#fde']],
        despair_crystal: [[null, '#aaf', '#aaf', null], ['#aaf', '#fff', '#fff', '#aaf'], ['#aaf', '#fff', '#fff', '#aaf'], [null, '#aaf', '#aaf', null]],
        sleeping_bag: [[null, '#d88', '#d88', '#c66'], [null, '#d88', '#c66', '#c66'], ['#432', '#432', '#432', '#432']],
        campfire: [[null, '#f80', '#fc0', null], ['#f80', '#a00', '#f80', '#fc0'], ['#888', '#777', '#888', '#777']],
        flashlight: [[null, '#ddd', '#ddd'], ['#666', '#444', '#444'], ['#666', '#444', '#444'], [null, '#666', null]],
        // --- Новая графика ---
        mutant_human: [['#bda', '#bda', null, null],['#494', '#494', '#bda', '#bda'],['#494', '#494', '#f00', '#494'],['#bda', '#bda', '#494', '#494'],[null, null, '#864', '#864']],
        archangel: [['#ff0', '#ff0', '#ff0', '#ff0'],['#fff', '#ff0', '#ff0', '#fff'],[null, '#fff', '#fff', null],['#eee', '#eee', '#eee', '#eee'],['#eee', null, null, '#eee']],
        demon: [['#f00', null, null, '#f00'],['#400', '#f00', '#f00', '#400'],['#400', '#200', '#200', '#400'],[null, '#200', '#200', null],['#100', null, null, '#100']],
        false_angel: (f) => [[f ? '#ccc' : '#bbb', '#ccc', f ? '#ccc' : '#bbb'], [null, '#aaa', null]],
        fire_axe: [['#f80', '#f60', null],[null, '#643', '#f80'],[null, '#643', null],[null, '#643', null]],
        fire_pickaxe: [['#f80', '#f80', '#f80'],[null, '#643', null],[null, '#643', null],[null, '#643', null]],
        fire_sword: [[null, '#f80', null],[null, '#f60', null],[null, '#ff0', null],[null, '#643', null]],
        archangel_orb: [[null, '#ff0', '#ff0', null], ['#ff0', '#fff', '#fff', '#ff0'], ['#ff0', '#fff', '#fff', '#ff0'], [null, '#ff0', '#ff0', null]],
    };
    const drawPixelArtOnCtx = (tCtx, x, y, s, p) => {
        const pS = s / p.length;
        for (let row = 0; row < p.length; row++) for (let col = 0; col < p[row].length; col++) {
            if (p[row][col]) { tCtx.fillStyle = p[row][col]; tCtx.fillRect(Math.floor(x + col*pS), Math.floor(y + row*pS), Math.ceil(pS), Math.ceil(pS)); }
        }
    };
    const drawPixelArt = (x, y, size, pixels) => drawPixelArtOnCtx(ctx, x, y, size, pixels);
    
    // --- Справочник ---
    const HANDBOOK_DATA = {
        "Существа": {
            "Тень": {
                description: "Слабое, но быстрое существо тьмы. Боится света. После смерти оставляет после себя Шар Тьмы. Урон: 25.",
                art: art.shadow(false)
            },
            "Человек": {
                description: "Обычный человек, застрявший в Лимбо. Обычно пассивен и восстанавливает ваш рассудок, если вы рядом. Однако, если его спровоцировать, он станет агрессивным. Урон (агрессивный): 45.",
                art: art.human
            },
            "Ангел": {
                description: "Светлое существо, которое мощно восстанавливает ваш рассудок. Не атакуйте его, иначе ваш рассудок сильно пострадает.",
                art: art.angel(false)
            },
            "Лже-Ангел": {
                description: "Выглядит как ангел, но является порождением тьмы. Быстро истощает ваш рассудок, если вы находитесь рядом.",
                art: art.false_angel(false)
            },
        },
        "Боссы": {
             "Мутировавший Человек": {
                description: "Огромный и агрессивный гуманоид. Атакует вблизи, нанося двойной урон (80) и сильно отбрасывая игрока.",
                art: art.mutant_human
            },
            "Архангел": {
                description: "Могущественное светлое существо, искаженное тьмой. Стреляет веером из трёх энергетических шаров, каждый наносит 15 урона.",
                art: art.archangel
            },
            "Демон": {
                description: "Повелитель теней. Не атакует сам, но призывает на помощь двух Теней. Очень живуч.",
                art: art.demon
            }
        },
        "Предметы": {
            "Топор (Деревянный)": { description: "Простой топор для рубки деревьев.", art: art.axe },
            "Кирка (Деревянная)": { description: "Простая кирка для добычи камня.", art: art.pickaxe },
            "Меч (Деревянный)": { description: "Простой меч для защиты. Урон: 3.", art: art.sword },
            "Топор (Каменный)": { description: "Более прочный топор. Добывает в 2 раза больше ресурсов.", art: art.stone_axe },
            "Кирка (Каменный)": { description: "Более прочная кирка. Добывает в 2 раза больше ресурсов.", art: art.stone_pickaxe },
            "Меч (Каменный)": { description: "Более прочный меч. Урон: 5.", art: art.stone_sword },
            "Топор (Огненный)": { description: "Мощный топор, который рубит сразу несколько деревьев и поджигает врагов вокруг вас. Замедляет при ношении. Урон ауры: 15/сек.", art: art.fire_axe },
            "Кирка (Огненная)": { description: "Очень быстро ломает камни, добывая много ресурсов.", art: art.fire_pickaxe },
            "Меч (Огненный)": { description: "Очень мощный меч. Урон: 25.", art: art.fire_sword },
            "Целебная мазь": { description: "Восстанавливает 50 единиц рассудка при использовании.", art: art.mental_salve },
            "Кристалл отчаянья": { description: "Телепортирует вас к ближайшему Ангелу. Используйте с умом.", art: art.despair_crystal },
            "Спальный мешок": { description: "Позволяет пропустить ночь и полностью восстановить рассудок. Есть шанс, что во время сна у вас украдут предметы.", art: art.sleeping_bag },
            "Костёр": { description: "Источник света и тепла. Восстанавливает рассудок в небольшом радиусе и ускоряет течение времени ночью.", art: art.campfire },
            "Фонарик": { description: "Освещает область перед вами, нанося урон Теням. Урон: 10/сек.", art: art.flashlight },
        },
        "Ресурсы": {
            "Дерево": { description: "Основной ресурс для создания инструментов и построек. Добывается из деревьев.", art: art.wood_block },
            "Камень": { description: "Основной ресурс для создания каменных инструментов и построек. Добывается из скал.", art: art.stone_block },
            "Шар Тьмы": { description: "Эссенция тьмы, выпадающая из Теней. Используется в мощных рецептах.", art: art.dark_orb },
            "Жёлудь": { description: "Иногда выпадает из дубов. Компонент для крафта.", art: art.acorn },
            "Лепесток сакуры": { description: "Выпадает из сакуры. Используется для призыва союзников и крафта.", art: art.sakura_petal },
        },
        "Растения": {
            "Дерево": { description: "Источник дерева.", art: art.tree },
            "Береза": { description: "Дает больше дерева, чем обычное.", art: art.birch },
            "Дуб": { description: "Источник дерева и желудей.", art: art.oak },
            "Сакура": { description: "Источник дерева и лепестков сакуры.", art: art.sakura },
            "Скала": { description: "Источник камня.", art: art.rock },
        }
    };


    // --- Поиск пути A* ---
    function findPath(startX, startY, endX, endY) {
        const openList = [], closedList = [], grid = world;
        const maxIterations = 2000; // Ограничение, чтобы избежать зависаний
        let iterations = 0;
        const startNode = { x: startX, y: startY, g: 0, h: Math.abs(endX - startX) + Math.abs(endY - startY), f: 0, parent: null };
        startNode.f = startNode.h; openList.push(startNode);
        while (openList.length > 0 && iterations < maxIterations) {
            iterations++;
            let lowInd = 0;
            for (let i = 0; i < openList.length; i++) { if (openList[i].f < openList[lowInd].f) lowInd = i; }
            const currentNode = openList[lowInd];
            if (currentNode.x === endX && currentNode.y === endY) {
                let curr = currentNode; const ret = [];
                while (curr.parent) { ret.push({x: curr.x * TILE_SIZE + TILE_SIZE / 2, y: curr.y * TILE_SIZE + TILE_SIZE / 2}); curr = curr.parent; }
                return ret.reverse();
            }
            openList.splice(lowInd, 1); closedList.push(currentNode);
            const neighbors = []; const x = currentNode.x; const y = currentNode.y;
            if (x > 0) neighbors.push({ x: x - 1, y }); if (x < WORLD_WIDTH - 1) neighbors.push({ x: x + 1, y });
            if (y > 0) neighbors.push({ x, y: y - 1 }); if (y < WORLD_HEIGHT - 1) neighbors.push({ x, y: y + 1 });
            for (const neighbor of neighbors) {
                if (isSolid(grid[neighbor.x]?.[neighbor.y]) || closedList.some(n => n.x === neighbor.x && n.y === neighbor.y)) continue;
                const gScore = currentNode.g + 1; let gScoreIsBest = false;
                let neighborNode = openList.find(n => n.x === neighbor.x && n.y === neighbor.y);
                if (!neighborNode) {
                    gScoreIsBest = true; neighborNode = { x: neighbor.x, y: neighbor.y, h: Math.abs(endX - neighbor.x) + Math.abs(endY - neighbor.y), parent: currentNode };
                    openList.push(neighborNode);
                } else if (gScore < neighborNode.g) gScoreIsBest = true;
                if (gScoreIsBest) { neighborNode.parent = currentNode; neighborNode.g = gScore; neighborNode.f = neighborNode.g + neighborNode.h; }
            }
        }
        return null; // Путь не найден (или превышен лимит итераций)
    }

    // --- Игровой цикл ---
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
    }
    
    function initGame() {
        resizeCanvas();
        player = { x: (WORLD_WIDTH * TILE_SIZE) / 2, y: (WORLD_HEIGHT * TILE_SIZE) / 2, speed: 150, mentalHealth: 100, maxMentalHealth: 100,
            inventory: Array(15).fill(null), attackCooldown: 0, stunTimer: 0, knockback: {x: 0, y: 0} };
        player.inventory[0] = { type: ITEM_TYPES.AXE, count: 1 };
        player.inventory[1] = { type: ITEM_TYPES.PICKAXE, count: 1 };
        player.inventory[2] = { type: ITEM_TYPES.SWORD, count: 1 };
        camera = { x: 0, y: 0 };
        world = Array(WORLD_WIDTH).fill(0).map(() => Array(WORLD_HEIGHT).fill(TILE_TYPES.EMPTY));
        entities = [];
        placedObjects = [];
        traps = [];
        projectiles = [];
        mousePos = { x: canvas.width / 2, y: canvas.height / 2 };
        generateWorld();
        gameState = 'playing';
        gameOverScreen.style.display = 'none';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    function generateWorld() {
        for (let x = 0; x < WORLD_WIDTH; x++) for (let y = 0; y < WORLD_HEIGHT; y++) {
            const n = Math.random();
            if (n > 0.98) world[x][y] = TILE_TYPES.ROCK;
            else if (n > 0.97) world[x][y] = TILE_TYPES.OAK;
            else if (n > 0.96) world[x][y] = TILE_TYPES.SAKURA;
            else if (n > 0.95) world[x][y] = TILE_TYPES.BIRCH;
            else if (n > 0.93) world[x][y] = TILE_TYPES.TREE;
        }
    }
    function gameLoop(timestamp) {
        if (gameState === 'start') return;
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        if (gameState !== 'paused') update(deltaTime);
        draw();
        if (gameState !== 'game_over') requestAnimationFrame(gameLoop);
    }
    
    // --- Обновление состояния ---
    function update(dt) {
        let timeScale = 1;
        const hour = Math.floor((gameTime % DAY_DURATION_SECONDS) / (DAY_DURATION_SECONDS / 24));
        const isNight = hour >= 20 || hour < 5;
        if (isNight) {
            const isNearCampfire = placedObjects.some(obj => 
                obj.type === 'CAMPFIRE' && Math.hypot(player.x - obj.x, player.y - obj.y) < CAMPFIRE_LIGHT_RADIUS
            );
            if (isNearCampfire) {
                timeScale = 2;
            }
        }
        
        const effectiveDt = dt * timeScale;
        gameTime += effectiveDt;

        const selectedItem = player.inventory[selectedHotbarSlot];

        if (player.stunTimer > 0) {
            player.stunTimer -= dt;
        } else {
             if (Math.abs(player.knockback.x) > 0.1 || Math.abs(player.knockback.y) > 0.1) {
                const knockbackMoveX = player.knockback.x * dt;
                const knockbackMoveY = player.knockback.y * dt;
                const nextX = player.x + knockbackMoveX;
                const nextY = player.y + knockbackMoveY;
                if (!isSolid(world[Math.floor(nextX / TILE_SIZE)]?.[Math.floor(nextY / TILE_SIZE)])) {
                    player.x = nextX;
                    player.y = nextY;
                }
                player.knockback.x *= 0.9; // Friction
                player.knockback.y *= 0.9;
            } else {
                let currentSpeed = player.speed;
                if (selectedItem && selectedItem.type === ITEM_TYPES.FIRE_AXE) {
                    currentSpeed *= 0.7; // Замедление на 30%
                }

                let dx = 0, dy = 0;
                if (keys['w'] || keys['ArrowUp']) dy -= 1; if (keys['s'] || keys['ArrowDown']) dy += 1;
                if (keys['a'] || keys['ArrowLeft']) dx -= 1; if (keys['d'] || keys['ArrowRight']) dx += 1;
                if (joystick.active) { dx += joystick.dx; dy += joystick.dy; }
                if (dx !== 0 || dy !== 0) {
                    const mag = Math.sqrt(dx*dx + dy*dy);
                    const moveX = (dx / mag) * currentSpeed * dt, moveY = (dy / mag) * currentSpeed * dt;
                    const nextX = player.x + moveX, nextY = player.y + moveY;
                    if (!isSolid(world[Math.floor(nextX / TILE_SIZE)]?.[Math.floor(nextY / TILE_SIZE)])) { player.x = nextX; player.y = nextY; }
                }
            }
        }
        
        // Аура урона от огненного топора
        if (selectedItem && selectedItem.type === ITEM_TYPES.FIRE_AXE) {
            entities.forEach(e => {
                if (e.type === ENTITY_TYPES.SHADOW || e.type === ENTITY_TYPES.DEMON || (e.type === ENTITY_TYPES.HUMAN && e.aggressive) || e.type === ENTITY_TYPES.MUTANT_HUMAN) {
                    if (Math.hypot(player.x - e.x, player.y - e.y) < TILE_SIZE * 1.5) {
                        e.health -= 15 * dt; // 15 урона в секунду
                    }
                }
            });
        }
        
        // Проверка столкновения с ловушками
        for (let i = traps.length - 1; i >= 0; i--) {
            const trap = traps[i];
            if (Math.hypot(player.x - trap.x, player.y - trap.y) < TILE_SIZE / 2) {
                if (trap.type === 'BEAR_TRAP') {
                    player.stunTimer = PLAYER_STUN_DURATION;
                    showNotification("Вы попали в капкан!");
                } else if (trap.type === 'TRIPWIRE') {
                    player.mentalHealth -= 30;
                    showNotification("Вы задели растяжку!");
                }
                traps.splice(i, 1);
                break;
            }
        }

        player.mentalHealth -= MENTAL_HEALTH_DRAIN_RATE * dt;
        
        updatePlacedObjects(dt);
        updateProjectiles(dt);
        handleFlashlight(dt);
        updateEntities(dt);

        spawnEntities();
        spawnTraps();
        if (player.attackCooldown > 0) player.attackCooldown -= dt;
        if (player.mentalHealth <= 0) { player.mentalHealth = 0; gameState = 'game_over'; gameOverScreen.style.display = 'flex'; }
    }
    function isSolid(tileType) {
        return tileType === TILE_TYPES.TREE || tileType === TILE_TYPES.ROCK || tileType === TILE_TYPES.WOOD_BLOCK ||
               tileType === TILE_TYPES.STONE_BLOCK || tileType === TILE_TYPES.BIRCH || tileType === TILE_TYPES.OAK ||
               tileType === TILE_TYPES.SAKURA;
    }
    function isPlayerPlaced(tileType) { return tileType === TILE_TYPES.WOOD_BLOCK || tileType === TILE_TYPES.STONE_BLOCK; }

    function updatePlacedObjects(dt) {
        for (let i = placedObjects.length - 1; i >= 0; i--) {
            const obj = placedObjects[i];
            obj.duration -= dt;
            if (obj.duration <= 0) {
                placedObjects.splice(i, 1);
                continue;
            }

            if (obj.type === 'CAMPFIRE') {
                const dist = Math.hypot(player.x - obj.x, player.y - obj.y);
                if (dist < CAMPFIRE_HEAL_RADIUS) {
                    player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + CAMPFIRE_HEAL_RATE * dt);
                }
            }
        }
    }
    
    function updateProjectiles(dt) {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.lifetime -= dt;

            const gridX = Math.floor(p.x / TILE_SIZE);
            const gridY = Math.floor(p.y / TILE_SIZE);

            if (p.lifetime <= 0 || isSolid(world[gridX]?.[gridY])) {
                projectiles.splice(i, 1);
                continue;
            }

            if (Math.hypot(p.x - player.x, p.y - player.y) < TILE_SIZE * 0.75) {
                player.mentalHealth -= p.damage;
                projectiles.splice(i, 1);
                continue;
            }
        }
    }

    function getFlashlightAngle() {
        if (joystick.active && (joystick.dx !== 0 || joystick.dy !== 0)) {
            return Math.atan2(joystick.dy, joystick.dx);
        }
        return Math.atan2(mousePos.y - canvas.height / 2, mousePos.x - canvas.width / 2);
    }

    function handleFlashlight(dt) {
        const selectedItem = player.inventory[selectedHotbarSlot];
        if (!selectedItem || selectedItem.type !== ITEM_TYPES.FLASHLIGHT || gameState !== 'playing') {
            return;
        }

        const angle = getFlashlightAngle();

        for (let i = entities.length - 1; i >= 0; i--) {
            const e = entities[i];
            if (e.type === ENTITY_TYPES.SHADOW) {
                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                if (dist > 0 && dist < FLASHLIGHT_RANGE) {
                    const angleToShadow = Math.atan2(e.y - player.y, e.x - player.x);
                    let angleDiff = Math.abs(angle - angleToShadow);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; // Учет перехода через 180/-180 градусов

                    if (angleDiff < FLASHLIGHT_CONE_ANGLE / 2) {
                        e.health -= FLASHLIGHT_DAMAGE * dt;
                        if (e.health <= 0) {
                             if (Math.random() < 1/3) {
                                 addItemToInventory(ITEM_TYPES.DARK_ORB, 1);
                                 showNotification("+1 Шар Тьмы");
                             }
                             entities.splice(i, 1); // Безопасное удаление
                        }
                    }
                }
            }
        }
    }


    function updateEntities(dt) {
        for (let i = entities.length - 1; i >= 0; i--) {
            const e = entities[i];
            if (!e) continue;
            if (e.health <= 0) {
                if (e.isBoss) {
                    const drops = [ITEM_TYPES.FIRE_AXE, ITEM_TYPES.FIRE_PICKAXE, ITEM_TYPES.FIRE_SWORD];
                    const droppedTool = drops[Math.floor(Math.random() * drops.length)];
                    addItemToInventory(droppedTool, 1);
                    showNotification(`Босс повержен! Вы получили: ${droppedTool.name}`);
                }
                entities.splice(i, 1);
                continue;
            }
            if (e.hitTimer > 0) e.hitTimer -= dt;
            if (e.attackCooldown > 0) e.attackCooldown -= dt;


            let moveX = 0, moveY = 0;
            let isKnockedBack = Math.abs(e.knockback.x) > 0.1 || Math.abs(e.knockback.y) > 0.1;

            if (isKnockedBack) {
                moveX = e.knockback.x * dt;
                moveY = e.knockback.y * dt;
                e.knockback.x *= 0.9; // Friction
                e.knockback.y *= 0.9;
            } else {
                 // --- Логика Боссов и агрессивных мобов ---
                if (e.isBoss || (e.type === ENTITY_TYPES.HUMAN && e.aggressive) || e.type === ENTITY_TYPES.SHADOW) {
                    let target = {x: player.x, y: player.y};
                    if (e.type === ENTITY_TYPES.SHADOW) {
                        let closestDist = Math.hypot(e.x - player.x, e.y - player.y);
                        entities.forEach(otherE => {
                            if (otherE && otherE.type === ENTITY_TYPES.HUMAN && !otherE.aggressive) {
                                const dist = Math.hypot(e.x - otherE.x, e.y - otherE.y);
                                if (dist < closestDist) { closestDist = dist; target = otherE; }
                            }
                        });
                    }

                    e.pathUpdateTimer -= dt;
                    if (e.pathUpdateTimer <= 0) {
                        e.pathUpdateTimer = e.isBoss ? 0.5 : 1.0;
                        e.path = findPath(Math.floor(e.x / TILE_SIZE), Math.floor(e.y / TILE_SIZE), Math.floor(target.x / TILE_SIZE), Math.floor(target.y / TILE_SIZE));
                        if (!e.path && e.type !== ENTITY_TYPES.SHADOW) e.moveTimer = 0;
                    }
                    
                    if (e.path && e.path.length > 0) {
                        const pathTarget = e.path[0], angle = Math.atan2(pathTarget.y - e.y, pathTarget.x - e.x);
                        moveX = Math.cos(angle) * e.speed * dt; moveY = Math.sin(angle) * e.speed * dt;
                        if (Math.hypot(pathTarget.y - e.y, pathTarget.x - e.x) < TILE_SIZE / 2) e.path.shift();
                    } else if (e.type === ENTITY_TYPES.SHADOW) {
                        e.moveTimer -= dt;
                        if (e.moveTimer <= 0) { e.angle = Math.random() * Math.PI * 2; e.moveTimer = Math.random() * 2 + 1; }
                        moveX = Math.cos(e.angle) * e.speed * 0.5 * dt; moveY = Math.sin(e.angle) * e.speed * 0.5 * dt;
                    }
                } else if (e.type === ENTITY_TYPES.ANGEL || e.type === ENTITY_TYPES.FALSE_ANGEL || (e.type === ENTITY_TYPES.HUMAN && !e.aggressive)) {
                    e.moveTimer -= dt;
                    if (e.moveTimer <= 0) { e.angle = Math.random() * Math.PI * 2; e.moveTimer = Math.random() * 3 + 2; }
                    moveX = Math.cos(e.angle) * e.speed * dt; moveY = Math.sin(e.angle) * e.speed * dt;
                    
                    if (Math.hypot(e.x - player.x, e.y - player.y) < ANGEL_HEAL_RADIUS) {
                        if (e.type === ENTITY_TYPES.ANGEL) player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + ANGEL_HEAL_RATE * dt);
                        else if (e.type === ENTITY_TYPES.FALSE_ANGEL) player.mentalHealth -= 30 * dt;
                    }
                    if (e.type === ENTITY_TYPES.HUMAN && Math.hypot(e.x - player.x, e.y - player.y) < HUMAN_HEAL_RADIUS) {
                         player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + HUMAN_HEAL_RATE * dt);
                    }
                }
            }

            // --- ИСПРАВЛЕННАЯ ЛОГИКА АТАКИ ---
            // Проверка атаки вынесена ВНЕ условий движения
            if (e.attackCooldown <= 0) {
                const distToPlayer = Math.hypot(e.x - player.x, e.y - player.y);
                
                if (e.isBoss) {
                    if (e.type === ENTITY_TYPES.ARCHANGEL && distToPlayer < TILE_SIZE * 10) {
                        const angleToPlayer = Math.atan2(player.y - e.y, player.x - e.x);
                        const projectileSpeed = 200;
                        for (let k = -1; k <= 1; k++) {
                            const angle = angleToPlayer + (k * Math.PI / 16);
                            projectiles.push({ x: e.x, y: e.y, vx: Math.cos(angle) * projectileSpeed, vy: Math.sin(angle) * projectileSpeed, lifetime: 6, damage: e.damage });
                        }
                        e.attackCooldown = 3.5;
                    }
                    else if (e.type === ENTITY_TYPES.MUTANT_HUMAN && distToPlayer < TILE_SIZE * 2) {
                        player.mentalHealth -= e.damage * 2;
                        const angle = Math.atan2(player.y - e.y, player.x - e.x);
                        player.knockback.x = Math.cos(angle) * 500;
                        player.knockback.y = Math.sin(angle) * 500;
                        e.attackCooldown = 2.5;
                    }
                    else if (e.type === ENTITY_TYPES.DEMON && distToPlayer < TILE_SIZE * 8) {
                        for (let k = 0; k < 2; k++) {
                            const spawnAngle = Math.random() * Math.PI * 2;
                            const spawnDist = TILE_SIZE * 1.5;
                            spawnEntity(ENTITY_TYPES.SHADOW, e.x + Math.cos(spawnAngle) * spawnDist, e.y + Math.sin(spawnAngle) * spawnDist);
                        }
                        showNotification("Демон призывает тени!");
                        e.attackCooldown = 6;
                    }
                } 
                // Атака обычных врагов (теней и агрессивных людей)
                else if (((e.type === ENTITY_TYPES.HUMAN && e.aggressive) || e.type === ENTITY_TYPES.SHADOW) && distToPlayer < TILE_SIZE * 1.5) {
                    player.mentalHealth -= e.damage;
                    e.attackCooldown = 1.5;
                }
            }

            const nextX = e.x + moveX, nextY = e.y + moveY;
            if (!isSolid(world[Math.floor(nextX / TILE_SIZE)]?.[Math.floor(nextY / TILE_SIZE)])) { e.x = nextX; e.y = nextY; } 
            else { 
                if (isKnockedBack) { e.knockback.x = 0; e.knockback.y = 0; }
                else { e.moveTimer = 0; if (e.path) e.path = null; }
            } 
            e.x = Math.max(0, Math.min(e.x, WORLD_WIDTH * TILE_SIZE)); e.y = Math.max(0, Math.min(e.y, WORLD_HEIGHT * TILE_SIZE));
        }
    }
    function spawnEntities() {
        const day = Math.floor(gameTime / DAY_DURATION_SECONDS) + 1;

        if (entities.filter(e => e && e.type === ENTITY_TYPES.SHADOW).length < 10 && Math.random() < 0.01) spawnEntity(ENTITY_TYPES.SHADOW);
        if (entities.filter(e => e && e.type === ENTITY_TYPES.ANGEL).length < 3 && Math.random() < 0.002) spawnEntity(ENTITY_TYPES.ANGEL);
        if (entities.filter(e => e && e.type === ENTITY_TYPES.HUMAN).length < 5 && Math.random() < 0.005) spawnEntity(ENTITY_TYPES.HUMAN);
        if (entities.filter(e => e && e.type === ENTITY_TYPES.FALSE_ANGEL).length < 2 && Math.random() < 0.003) spawnEntity(ENTITY_TYPES.FALSE_ANGEL);

        if (day > 3) {
            const bossExists = entities.some(e => e && e.isBoss);
            if (!bossExists && Math.random() < 0.005) {
                const bossType = [ENTITY_TYPES.MUTANT_HUMAN, ENTITY_TYPES.ARCHANGEL, ENTITY_TYPES.DEMON][Math.floor(Math.random() * 3)];
                spawnEntity(bossType);
                showNotification("Вы чувствуете зловещее присутствие...");
            }
        }
    }
    
    function spawnTraps() {
        if (traps.length < 20 && Math.random() < 0.005) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(canvas.width, canvas.height) / 2;
            const x = player.x + Math.cos(angle) * radius;
            const y = player.y + Math.sin(angle) * radius;

            const gridX = Math.floor(x / TILE_SIZE), gridY = Math.floor(y / TILE_SIZE);
            if (gridX >= 0 && gridX < WORLD_WIDTH && gridY >= 0 && gridY < WORLD_HEIGHT && !isSolid(world[gridX][gridY])) {
                const type = Math.random() < 0.5 ? 'BEAR_TRAP' : 'TRIPWIRE';
                traps.push({ x, y, type });
            }
        }
    }
    function spawnEntity(type, spawnX, spawnY) {
        const angle = Math.random() * Math.PI * 2, radius = Math.max(canvas.width, canvas.height);
        const x = spawnX ?? player.x + Math.cos(angle) * radius;
        const y = spawnY ?? player.y + Math.sin(angle) * radius;
        const baseEntity = { x, y, health: 100, hitTimer: 0, knockback: { x: 0, y: 0 }, isBoss: false, path: null, pathUpdateTimer: 0, moveTimer: 0, angle: 0, attackCooldown: 0 };

        if (type === ENTITY_TYPES.SHADOW) entities.push({ ...baseEntity, type, speed: 130, health: 5, damage: 2 });
        else if (type === ENTITY_TYPES.ANGEL) entities.push({ ...baseEntity, type, speed: 30, health: 20 });
        else if (type === ENTITY_TYPES.FALSE_ANGEL) entities.push({ ...baseEntity, type, speed: 40, health: 50 });
        else if (type === ENTITY_TYPES.HUMAN) {
            const isAngry = (spawnX !== undefined) ? Math.random() < 0.5 : Math.random() < 0.3;
            entities.push({ ...baseEntity, type, speed: isAngry ? 75 : 50, health: 100, 
                aggressive: isAngry, 
                aggressionTimer: isAngry ? 30 : 0,
                damage: isAngry ? 10 : 10 });
        }
        else if (type === ENTITY_TYPES.MUTANT_HUMAN) entities.push({ ...baseEntity, isBoss: true, type, speed: 80, health: 500, damage: 40, aggressive: true, attackCooldown: 2 });
        else if (type === ENTITY_TYPES.ARCHANGEL) entities.push({ ...baseEntity, isBoss: true, type, speed: 60, health: 400, damage: 15, aggressive: true, attackCooldown: 3.5 });
        else if (type === ENTITY_TYPES.DEMON) entities.push({ ...baseEntity, isBoss: true, type, speed: 90, health: 666, damage: 25, aggressive: true, attackCooldown: 6 });
    }
    
    // --- Отрисовка ---
    function draw() {
        const hour = Math.floor((gameTime % DAY_DURATION_SECONDS) / (DAY_DURATION_SECONDS / 24));
        const isNight = hour >= 20 || hour < 5;
        const lightLevel = isNight ? 0.4 : 1.0;
        canvas.style.filter = `brightness(${lightLevel})`;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        camera.x = player.x - canvas.width / 2; camera.y = player.y - canvas.height / 2;
        const startCol = Math.floor(camera.x / TILE_SIZE), endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 1;
        const startRow = Math.floor(camera.y / TILE_SIZE), endRow = startRow + Math.ceil(canvas.height / TILE_SIZE) + 1;
        for (let x = startCol; x < endCol; x++) for (let y = startRow; y < endRow; y++) {
            if (x < 0 || y < 0 || x >= WORLD_WIDTH || y >= WORLD_HEIGHT) continue;
            const tile = world[x][y], dX = x * TILE_SIZE - camera.x, dY = y * TILE_SIZE - camera.y;
            if (tile === TILE_TYPES.TREE) drawPixelArt(dX, dY, TILE_SIZE, art.tree);
            else if (tile === TILE_TYPES.BIRCH) drawPixelArt(dX, dY, TILE_SIZE, art.birch);
            else if (tile === TILE_TYPES.OAK) drawPixelArt(dX, dY, TILE_SIZE, art.oak);
            else if (tile === TILE_TYPES.SAKURA) drawPixelArt(dX, dY, TILE_SIZE, art.sakura);
            else if (tile === TILE_TYPES.ROCK) drawPixelArt(dX, dY, TILE_SIZE, art.rock);
            else if (tile === TILE_TYPES.WOOD_BLOCK) drawPixelArt(dX, dY, TILE_SIZE, art.wood_block);
            else if (tile === TILE_TYPES.STONE_BLOCK) drawPixelArt(dX, dY, TILE_SIZE, art.stone_block);
        }
        
        projectiles.forEach(p => {
            const dX = p.x - camera.x - TILE_SIZE / 4;
            const dY = p.y - camera.y - TILE_SIZE / 4;
            drawPixelArt(dX, dY, TILE_SIZE / 2, art.archangel_orb);
        });

        placedObjects.forEach(obj => {
            if (obj.type === 'CAMPFIRE') {
                const dX = obj.x - camera.x, dY = obj.y - camera.y;
                const gradient = ctx.createRadialGradient(dX, dY, TILE_SIZE * 0.5, dX, dY, CAMPFIRE_LIGHT_RADIUS);
                gradient.addColorStop(0, 'rgba(255, 180, 50, 0.25)'); gradient.addColorStop(1, 'rgba(255, 180, 50, 0)');
                ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(dX, dY, CAMPFIRE_LIGHT_RADIUS, 0, Math.PI * 2); ctx.fill();
                drawPixelArt(dX - TILE_SIZE/2, dY - TILE_SIZE/2, TILE_SIZE, art.campfire);
            }
        });

        entities.forEach(e => {
            if (!e) return;
            const dX = e.x - camera.x, dY = e.y - camera.y;
            const size = e.isBoss ? TILE_SIZE * 2.5 : TILE_SIZE;
            
            if (e.type === ENTITY_TYPES.SHADOW) drawPixelArt(dX - size / 2, dY - size / 2, size, art.shadow(Math.random() > 0.5));
            else if (e.type === ENTITY_TYPES.ANGEL) { ctx.beginPath(); ctx.arc(dX, dY, ANGEL_HEAL_RADIUS, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.fill(); drawPixelArt(dX - TILE_SIZE / 2, dY - TILE_SIZE / 2, TILE_SIZE, art.angel(Math.random() > 0.5)); }
            else if (e.type === ENTITY_TYPES.FALSE_ANGEL) { ctx.beginPath(); ctx.arc(dX, dY, ANGEL_HEAL_RADIUS, 0, Math.PI * 2); ctx.fillStyle = 'rgba(128, 128, 128, 0.1)'; ctx.fill(); drawPixelArt(dX - TILE_SIZE / 2, dY - TILE_SIZE / 2, TILE_SIZE, art.false_angel(Math.random() > 0.5)); }
            else if (e.type === ENTITY_TYPES.HUMAN) {
                 if (!e.aggressive) { ctx.beginPath(); ctx.arc(dX, dY, HUMAN_HEAL_RADIUS, 0, Math.PI * 2); ctx.fillStyle = 'rgba(144, 238, 144, 0.05)'; ctx.fill(); } 
                 else { ctx.beginPath(); ctx.arc(dX, dY, TILE_SIZE * 1.5, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 0, 0, 0.1)'; ctx.fill(); }
                 drawPixelArt(dX - TILE_SIZE / 2, dY - TILE_SIZE / 2, TILE_SIZE, art.human);
            }
            else if (e.type === ENTITY_TYPES.MUTANT_HUMAN) drawPixelArt(dX - size / 2, dY - size / 2, size, art.mutant_human);
            else if (e.type === ENTITY_TYPES.ARCHANGEL) drawPixelArt(dX - size / 2, dY - size / 2, size, art.archangel);
            else if (e.type === ENTITY_TYPES.DEMON) drawPixelArt(dX - size / 2, dY - size / 2, size, art.demon);

            if (e.hitTimer > 0) {
                ctx.fillStyle = 'rgba(255, 50, 50, 0.6)';
                ctx.fillRect(dX - size / 2, dY - size / 2, size, size);
            }
        });
        
        if(player.stunTimer > 0) {
            ctx.fillStyle = "rgba(255, 255, 100, 0.3)";
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, TILE_SIZE, 0, Math.PI * 2);
            ctx.fill();
        }

        drawPixelArt(canvas.width/2 - TILE_SIZE/2, canvas.height/2 - TILE_SIZE/2, TILE_SIZE, art.player);
        
        const selectedItem = player.inventory[selectedHotbarSlot];
        
        if (selectedItem && selectedItem.type === ITEM_TYPES.FLASHLIGHT && gameState === 'playing') {
            const angle = getFlashlightAngle();
            const pX = canvas.width / 2, pY = canvas.height / 2;
            ctx.fillStyle = 'rgba(255, 255, 220, 0.15)';
            ctx.beginPath(); ctx.moveTo(pX, pY);
            ctx.arc(pX, pY, FLASHLIGHT_RANGE, angle - FLASHLIGHT_CONE_ANGLE / 2, angle + FLASHLIGHT_CONE_ANGLE / 2);
            ctx.lineTo(pX, pY); ctx.fill();
        }

        if (selectedItem && gameState === 'playing') {
            let artKey = Object.keys(ITEM_TYPES).find(key => ITEM_TYPES[key].id === selectedItem.type.id)?.toLowerCase();
            if (selectedItem.type.id === 'WOOD') artKey = 'wood_block';
            if (selectedItem.type.id === 'STONE') artKey = 'stone_block';
            if (art[artKey]) {
                const itemSize = TILE_SIZE * 0.7;
                const itemX = canvas.width / 2 + TILE_SIZE * 0.1;
                const itemY = canvas.height / 2 - TILE_SIZE * 0.1;
                drawPixelArt(itemX, itemY, itemSize, art[artKey]);
            }
        }
        
        if (gameState === 'paused') {
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
        }
        updateUI();
    }
    
    // --- UI и Инвентарь ---
    function showNotification(message) {
        const container = document.getElementById('notification-container');
        const notif = document.createElement('div');
        notif.className = 'notification-message';
        notif.textContent = message;
        container.appendChild(notif);
        setTimeout(() => {
            notif.remove();
        }, 5000);
    }

    function updateUI() {
        document.getElementById('mental-health-bar').style.width = `${(player.mentalHealth / player.maxMentalHealth) * 100}%`;
        const day = Math.floor(gameTime / DAY_DURATION_SECONDS) + 1;
        const timeInDay = gameTime % DAY_DURATION_SECONDS;
        const hour = Math.floor(timeInDay / (DAY_DURATION_SECONDS / 24));
        const minute = Math.floor((timeInDay % (DAY_DURATION_SECONDS / 24)) / (DAY_DURATION_SECONDS / 24 / 60));
        document.getElementById('day-counter').textContent = `День ${day}`;
        document.getElementById('time-display').textContent = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        
        const hotbar = document.getElementById('hotbar');
        hotbar.innerHTML = '';
        for (let i = 0; i < 5; i++) hotbar.appendChild(createSlotElement(i));
    }
    function createSlotElement(i, isInventorySlot = false) {
        const slot = document.createElement('div');
        slot.className = isInventorySlot ? 'inventory-slot' : 'hotbar-slot';
        if (isInventorySlot) slot.classList.add('hotbar-slot'); // Reuse styling
        slot.classList.toggle('selected', !isInventorySlot && i === selectedHotbarSlot);
        slot.dataset.slotIndex = i;
        slot.draggable = player.inventory[i] != null;
        
        const item = player.inventory[i];
        if (item) {
            const iconSize = 64; 
            const canvasIcon = document.createElement('canvas');
            canvasIcon.width = canvasIcon.height = iconSize; canvasIcon.className = 'item-icon';
            const iconCtx = canvasIcon.getContext('2d'); iconCtx.imageSmoothingEnabled = false;
            
            let artKey = Object.keys(ITEM_TYPES).find(key => ITEM_TYPES[key].id === item.type.id)?.toLowerCase();
            if (item.type.id === 'WOOD') artKey = 'wood_block';
            if (item.type.id === 'STONE') artKey = 'stone_block';
            
            if (art[artKey]) {
                drawPixelArtOnCtx(iconCtx, 0, 0, iconSize, art[artKey]);
            }
            slot.appendChild(canvasIcon);
            
            if (item.count > 1) {
                const itemCount = document.createElement('span'); itemCount.className = 'item-count';
                itemCount.innerText = item.count; slot.appendChild(itemCount);
            }
        }
        return slot;
    }
    function toggleInventory() {
        if (gameState === 'game_over' || handbookScreen.style.display === 'flex') return;
        const isOpening = gameState !== 'paused';
        gameState = isOpening ? 'paused' : 'playing';
        inventoryScreen.style.display = isOpening ? 'flex' : 'none';
        if (isOpening) {
            selectedRecipe = null;
            updateInventoryScreen();
        }
    }
    function updateInventoryScreen() {
        const inventoryGrid = document.getElementById('inventory-grid');
        inventoryGrid.innerHTML = '';
        for (let i = 0; i < player.inventory.length; i++) inventoryGrid.appendChild(createSlotElement(i, true));
        updateRecipeList();
    }
    function updateRecipeList() {
        const recipeList = document.getElementById('recipe-list');
        recipeList.innerHTML = '';
        RECIPES.forEach((recipe, index) => {
            const li = document.createElement('li');
            li.textContent = `${recipe.output.type.name} x${recipe.output.count}`;
            li.dataset.recipeIndex = index;
            const canCraft = canCraftRecipe(recipe);
            li.classList.toggle('un-craftable', !canCraft);
            li.classList.toggle('selected', selectedRecipe === recipe);
            li.addEventListener('click', () => { 
                if (selectedRecipe === recipe) {
                    selectedRecipe = null;
                } else {
                    selectedRecipe = recipe;
                }
                updateRecipeList();
            });
            recipeList.appendChild(li);
        });
        updateCraftingDetails();
    }
    function updateCraftingDetails() {
        const details = document.getElementById('crafting-details');
        const button = document.getElementById('craft-button');
        if (!selectedRecipe) {
            details.innerHTML = `<p>Выберите рецепт</p>`;
            button.disabled = true;
            return;
        }
        const canCraft = canCraftRecipe(selectedRecipe);
        let detailsHtml = `<h4>${selectedRecipe.output.type.name}</h4><ul>`;
        selectedRecipe.ingredients.forEach(ing => {
            const hasCount = countItems(ing.type);
            const hasEnough = hasCount >= ing.count;
            detailsHtml += `<li class="${!hasEnough ? 'needed-bad' : ''}" style="list-style: none;">${ing.type.name}: ${hasCount}/${ing.count}</li>`;
        });
        detailsHtml += `</ul>`;
        details.innerHTML = detailsHtml;
        button.disabled = !canCraft;
    }
    document.getElementById('craft-button').addEventListener('click', () => {
        if (selectedRecipe && canCraftRecipe(selectedRecipe)) {
            craftRecipe(selectedRecipe);
            updateInventoryScreen();
        }
    });

    // --- Логика предметов и крафта ---
    function countItems(itemType) {
        return player.inventory.reduce((sum, item) => item && item.type.id === itemType.id ? sum + item.count : sum, 0);
    }
    function canCraftRecipe(recipe) {
        return recipe.ingredients.every(ing => countItems(ing.type) >= ing.count);
    }
    function craftRecipe(recipe) {
        if (!canCraftRecipe(recipe)) return;
        recipe.ingredients.forEach(ing => removeItemFromInventory(ing.type, ing.count));
        addItemToInventory(recipe.output.type, recipe.output.count);
    }
    function addItemToInventory(itemType, count) {
        for (let i = 0; i < player.inventory.length; i++) {
            if (player.inventory[i] && player.inventory[i].type.id === itemType.id) { player.inventory[i].count += count; return true; }
        }
        for (let i = 0; i < player.inventory.length; i++) {
            if (!player.inventory[i]) { player.inventory[i] = { type: itemType, count }; return true; }
        }
        return false;
    }
    function removeItemFromInventory(itemType, count) {
        for (let i = player.inventory.length - 1; i >= 0; i--) {
            const item = player.inventory[i];
            if (item && item.type.id === itemType.id) {
                const toRemove = Math.min(count, item.count);
                item.count -= toRemove;
                count -= toRemove;
                if (item.count <= 0) player.inventory[i] = null;
                if (count <= 0) return true;
            }
        }
        return false;
    }
    
    // --- Взаимодействие ---
    function handleInteraction(clientX, clientY) {
        if (gameState !== 'playing' || player.attackCooldown > 0 || player.stunTimer > 0) return;
        if (isTouchDevice()) {
            const joyRect = joystickContainer.getBoundingClientRect();
            if (clientX >= joyRect.left && clientX <= joyRect.right && clientY >= joyRect.top && clientY <= joyRect.bottom) return;
            const bottomUiRect = document.getElementById('bottom-ui').getBoundingClientRect();
             if (clientY >= bottomUiRect.top) return;
        }
        const mouseX = clientX + camera.x, mouseY = clientY + camera.y;
        const gridX = Math.floor(mouseX / TILE_SIZE), gridY = Math.floor(mouseY / TILE_SIZE);
        const selectedItem = player.inventory[selectedHotbarSlot];

        if (selectedItem) {
            if (selectedItem.type === ITEM_TYPES.MENTAL_SALVE) { player.mentalHealth = Math.min(player.maxMentalHealth, player.mentalHealth + 50); removeItemFromInventory(ITEM_TYPES.MENTAL_SALVE, 1); player.attackCooldown = 0.5; return; }
            if (selectedItem.type === ITEM_TYPES.DESPAIR_CRYSTAL) {
                let nearestAngel = null, minDist = Infinity;
                entities.forEach(e => {
                    if (e && e.type === ENTITY_TYPES.ANGEL) {
                        const dist = Math.hypot(player.x - e.x, player.y - e.y);
                        if (dist < minDist) { minDist = dist; nearestAngel = e; }
                    }
                });
                if (nearestAngel) { player.x = nearestAngel.x; player.y = nearestAngel.y; removeItemFromInventory(ITEM_TYPES.DESPAIR_CRYSTAL, 1); } 
                else { showNotification("Поблизости нет ангелов, чтобы услышать твой зов."); }
                player.attackCooldown = 1; return;
            }
            if (selectedItem.type === ITEM_TYPES.SLEEPING_BAG) {
                const currentDay = Math.floor(gameTime / DAY_DURATION_SECONDS);
                const nextDayStart = (currentDay + 1) * DAY_DURATION_SECONDS;
                const randomHourFraction = (6 + Math.random() * 3) / 24;
                gameTime = nextDayStart + DAY_DURATION_SECONDS * randomHourFraction;
                
                player.mentalHealth = player.maxMentalHealth;
                removeItemFromInventory(ITEM_TYPES.SLEEPING_BAG, 1);
                if (Math.random() < 0.20) {
                    const itemsInInventory = player.inventory.map((item, index) => ({item, index})).filter(i => i.item != null);
                    if (itemsInInventory.length > 0) {
                        const stolen = itemsInInventory[Math.floor(Math.random() * itemsInInventory.length)];
                        const amountToRemove = Math.min(stolen.item.count, Math.floor(Math.random() * 5) + 1);
                        showNotification(`Пока ты спал, у тебя украли ${stolen.item.type.name} в количестве ${amountToRemove}`);
                        removeItemFromInventory(stolen.item.type, amountToRemove);
                    }
                }
                player.attackCooldown = 1; return;
            }
            if (selectedItem.type === ITEM_TYPES.SAKURA_PETAL) { spawnEntity(ENTITY_TYPES.HUMAN, player.x, player.y + TILE_SIZE * 1.5); removeItemFromInventory(ITEM_TYPES.SAKURA_PETAL, 1); player.attackCooldown = 0.5; return; }
        }

        let didAttack = false;
        const toolType = selectedItem?.type.id;
        if (toolType && toolType.includes('SWORD')) {
            let swordDamage = 3, knockbackForce = 250, range = TILE_SIZE * 1.2;
            if(toolType === 'STONE_SWORD') { swordDamage = 5; knockbackForce = 300; }
            if(toolType === 'FIRE_SWORD') { swordDamage = 25; knockbackForce = 400; range = TILE_SIZE * 1.5; }
            
            entities.forEach(e => { 
                 if (!e) return;
                if (Math.hypot(e.x - mouseX, e.y - mouseY) < range) {
                    e.health -= swordDamage;
                    if (e.type === ENTITY_TYPES.HUMAN && !e.isBoss) { e.aggressive = true; e.aggressionTimer = 30; } 
                    else if (e.type === ENTITY_TYPES.ANGEL) { player.mentalHealth *= 0.5; }
                    
                    e.hitTimer = 0.2;
                    const angle = Math.atan2(e.y - player.y, e.x - player.x);
                    e.knockback.x = Math.cos(angle) * knockbackForce;
                    e.knockback.y = Math.sin(angle) * knockbackForce;
                    didAttack = true;

                    if (e.health <= 0) {
                        if (e.type === ENTITY_TYPES.SHADOW) addItemToInventory(ITEM_TYPES.DARK_ORB, 1);
                        else if (e.type === ENTITY_TYPES.HUMAN && !e.isBoss) addItemToInventory(ITEM_TYPES.MENTAL_SALVE, 1);
                    }
                }
            });
            if (didAttack) { player.attackCooldown = 0.5; return; }
        }

        if (gridX < 0 || gridY < 0 || gridX >= WORLD_WIDTH || gridY >= WORLD_HEIGHT) return;
        const tile = world[gridX][gridY];

        const yieldMultiplier = 5;
        if (selectedItem && selectedItem.type === ITEM_TYPES.FIRE_AXE && (tile === TILE_TYPES.TREE || tile === TILE_TYPES.BIRCH || tile === TILE_TYPES.OAK || tile === TILE_TYPES.SAKURA)) {
            for (let i = -1; i <= 1; i++) for (let j = -1; j <= 1; j++) {
                const nX = gridX + i, nY = gridY + j;
                if (nX >= 0 && nX < WORLD_WIDTH && nY >= 0 && nY < WORLD_HEIGHT) {
                    const nearTile = world[nX][nY];
                    if (nearTile === TILE_TYPES.TREE) { world[nX][nY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 1 * yieldMultiplier); }
                    else if (nearTile === TILE_TYPES.BIRCH) { world[nX][nY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 2 * yieldMultiplier); }
                    else if (nearTile === TILE_TYPES.OAK) { world[nX][nY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 1 * yieldMultiplier); if (Math.random() < 0.5) addItemToInventory(ITEM_TYPES.ACORN, 1 * yieldMultiplier); } 
                    else if (nearTile === TILE_TYPES.SAKURA) { world[nX][nY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 1 * yieldMultiplier); addItemToInventory(ITEM_TYPES.SAKURA_PETAL, 1 * yieldMultiplier); }
                }
            }
            player.attackCooldown = 1.5; return;
        }
        if (selectedItem && selectedItem.type === ITEM_TYPES.FIRE_PICKAXE && tile === TILE_TYPES.ROCK) {
            world[gridX][gridY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.STONE, 1 * yieldMultiplier); player.attackCooldown = 0.5; return;
        }

        if (isPlayerPlaced(tile)) { 
            if (tile === TILE_TYPES.WOOD_BLOCK) addItemToInventory(ITEM_TYPES.WOOD, 1);
            else if (tile === TILE_TYPES.STONE_BLOCK) addItemToInventory(ITEM_TYPES.STONE, 1);
            world[gridX][gridY] = TILE_TYPES.EMPTY; return;
        }
        if (!selectedItem) return;
        const toolPower = selectedItem.type.id.includes('STONE') ? 2 : 1;
        if (tile === TILE_TYPES.TREE && toolType.includes('AXE')) { world[gridX][gridY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 1 * toolPower); } 
        else if (tile === TILE_TYPES.BIRCH && toolType.includes('AXE')) { world[gridX][gridY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 2 * toolPower); } 
        else if (tile === TILE_TYPES.OAK && toolType.includes('AXE')) { world[gridX][gridY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 1 * toolPower); if (Math.random() < 0.5) addItemToInventory(ITEM_TYPES.ACORN, 1); }
        else if (tile === TILE_TYPES.SAKURA && toolType.includes('AXE')) { world[gridX][gridY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.WOOD, 1 * toolPower); addItemToInventory(ITEM_TYPES.SAKURA_PETAL, 1 * toolPower); }
        else if (tile === TILE_TYPES.ROCK && toolType.includes('PICKAXE')) { world[gridX][gridY] = TILE_TYPES.EMPTY; addItemToInventory(ITEM_TYPES.STONE, 1 * toolPower); } 
        else if (tile === TILE_TYPES.EMPTY) {
            if (selectedItem.type === ITEM_TYPES.WOOD && countItems(ITEM_TYPES.WOOD) > 0) { world[gridX][gridY] = TILE_TYPES.WOOD_BLOCK; removeItemFromInventory(ITEM_TYPES.WOOD, 1); } 
            else if (selectedItem.type === ITEM_TYPES.STONE && countItems(ITEM_TYPES.STONE) > 0) { world[gridX][gridY] = TILE_TYPES.STONE_BLOCK; removeItemFromInventory(ITEM_TYPES.STONE, 1); }
            else if (selectedItem.type === ITEM_TYPES.CAMPFIRE && countItems(ITEM_TYPES.CAMPFIRE) > 0) {
                placedObjects.push({ type: 'CAMPFIRE', x: gridX * TILE_SIZE + TILE_SIZE/2, y: gridY * TILE_SIZE + TILE_SIZE/2, duration: CAMPFIRE_DURATION });
                removeItemFromInventory(ITEM_TYPES.CAMPFIRE, 1);
            }
        }
    }
    
    // --- Управление и UI ---
    
    function toggleHandbook() {
        if (gameState === 'game_over' || inventoryScreen.style.display === 'flex') return;
        const isOpening = handbookScreen.style.display === 'none';
        if (isOpening) {
            gameState = 'paused';
            handbookScreen.style.display = 'flex';
            populateHandbook(Object.keys(HANDBOOK_DATA)[0]);
        } else {
            gameState = 'playing';
            handbookScreen.style.display = 'none';
        }
    }

    function populateHandbook(activeCategory) {
        const tabsContainer = document.getElementById('handbook-tabs');
        const contentContainer = document.getElementById('handbook-content');
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = '';

        Object.keys(HANDBOOK_DATA).forEach(category => {
            const tab = document.createElement('div');
            tab.className = 'handbook-tab';
            tab.textContent = category;
            if (category === activeCategory) {
                tab.classList.add('active');
            }
            tab.addEventListener('click', () => populateHandbook(category));
            tabsContainer.appendChild(tab);
        });

        const categoryData = HANDBOOK_DATA[activeCategory];
        for (const itemName in categoryData) {
            const itemData = categoryData[itemName];
            const entry = document.createElement('div');
            entry.className = 'handbook-entry';

            const iconCanvas = document.createElement('canvas');
            iconCanvas.width = iconCanvas.height = 48;
            iconCanvas.className = 'handbook-entry-icon';
            const iconCtx = iconCanvas.getContext('2d');
            iconCtx.imageSmoothingEnabled = false;
            drawPixelArtOnCtx(iconCtx, 0, 0, 48, itemData.art);

            const textDiv = document.createElement('div');
            textDiv.className = 'handbook-entry-text';
            textDiv.innerHTML = `<h3>${itemName}</h3><p>${itemData.description}</p>`;
            
            entry.appendChild(iconCanvas);
            entry.appendChild(textDiv);
            contentContainer.appendChild(entry);
        }
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('keydown', (e) => {
        if (gameState === 'start' || gameState === 'game_over') return;
        const key = e.key.toLowerCase();
        
        if (key === 'escape') {
            if (inventoryScreen.style.display === 'flex') toggleInventory();
            if (handbookScreen.style.display === 'flex') toggleHandbook();
            return;
        }

        if (gameState === 'paused') return;

        keys[key] = true;
        if (key >= '1' && key <= '5') selectedHotbarSlot = parseInt(key) - 1;
        if (key === 'e' || key === 'i') {
            toggleInventory();
        }
    });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
    window.addEventListener('mousemove', (e) => {
        mousePos.x = e.clientX;
        mousePos.y = e.clientY;
    });
    canvas.addEventListener('mousedown', (e) => { if (e.button === 0) handleInteraction(e.clientX, e.clientY); });
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInteraction(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    
    startButton.addEventListener('click', () => { startScreen.style.display = 'none'; initGame(); });
    restartButton.addEventListener('click', () => { initGame(); });
    prequelButton.addEventListener('click', () => { startScreen.style.display = 'none'; prequelScreen.style.display = 'flex'; });
    backFromPrequelButton.addEventListener('click', () => { prequelScreen.style.display = 'none'; startScreen.style.display = 'flex'; });
    handbookButton.addEventListener('click', toggleHandbook);
    handbookCloseButton.addEventListener('click', toggleHandbook);

    inventoryScreen.addEventListener('click', (e) => {
        if (e.target === inventoryScreen) { 
            toggleInventory();
        }
    });

    const inventoryButtonMobile = document.getElementById('inventory-button-mobile');
    inventoryButtonMobile.addEventListener('click', toggleInventory);

    let draggedItemIndex = null;
    
    function handleDragStart(e) {
        draggedItemIndex = parseInt(e.target.dataset.slotIndex);
        e.dataTransfer.effectAllowed = 'move';
        setTimeout(() => e.target.classList.add('dragging'), 0);
    }

    function handleDragEnd(e) {
        e.target.classList.remove('dragging');
        draggedItemIndex = null;
    }
    
    function handleDragOver(e) { e.preventDefault(); }

    function handleDrop(e) {
        e.preventDefault();
        const targetSlot = e.target.closest('.hotbar-slot, .inventory-slot');
        if (targetSlot && draggedItemIndex !== null) {
            const droppedOnIndex = parseInt(targetSlot.dataset.slotIndex);
            const temp = player.inventory[draggedItemIndex];
            player.inventory[draggedItemIndex] = player.inventory[droppedOnIndex];
            player.inventory[droppedOnIndex] = temp;
            if (gameState === 'paused' && inventoryScreen.style.display === 'flex') updateInventoryScreen();
            updateUI();
        }
    }
    
    document.getElementById('hotbar').addEventListener('click', (e) => {
        const slot = e.target.closest('.hotbar-slot');
        if (slot) selectedHotbarSlot = parseInt(slot.dataset.slotIndex);
    });
    const setupDragListeners = (container) => {
        container.addEventListener('dragstart', handleDragStart);
        container.addEventListener('dragend', handleDragEnd);
        container.addEventListener('dragover', handleDragOver);
        container.addEventListener('drop', handleDrop);
    };
    setupDragListeners(document.getElementById('inventory-screen'));
    setupDragListeners(document.getElementById('hotbar'));

    function isTouchDevice() { return 'ontouchstart' in window || navigator.maxTouchPoints > 0; }
    if (isTouchDevice()) {
        joystickContainer.style.display = 'block';
        inventoryButtonMobile.style.display = 'flex';
        joystickContainer.innerHTML = `<div id="joystick-handle"></div>`;
        joystickContainer.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; }, { passive: false });
        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault(); if (!joystick.active) return;
            const touch = e.touches[0];
            const rect = joystickContainer.getBoundingClientRect();
            const joySize = rect.width, maxDist = joySize / 2.5;
            const joyX = rect.left + joySize / 2, joyY = rect.top + joySize / 2;
            let dx = touch.clientX - joyX, dy = touch.clientY - joyY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
            document.getElementById('joystick-handle').style.transform = `translate(${dx}px, ${dy}px)`;
            if (dist > 5) { joystick.dx = (touch.clientX - joyX) / maxDist; joystick.dy = (touch.clientY - joyY) / maxDist; }
            else { joystick.dx = 0; joystick.dy = 0;}
        }, { passive: false });
        window.addEventListener('touchend', (e) => {
            let joyTouchEnded = true; 
            for(let i = 0; i < e.touches.length; i++) {
                 const touch = e.touches[i];
                 const rect = joystickContainer.getBoundingClientRect();
                 if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
                    touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
                     joyTouchEnded = false;
                     break;
                 }
            }
            if(joyTouchEnded) {
                joystick.active = false; joystick.dx = 0; joystick.dy = 0;
                document.getElementById('joystick-handle').style.transform = 'translate(0px, 0px)';
            }
        });
        
        let touchDraggedSlot = null;
        const inventoryGrid = document.getElementById('inventory-grid');
        
        inventoryGrid.addEventListener('touchstart', (e) => {
             if (e.target.closest('.hotbar-slot') && player.inventory[e.target.closest('.hotbar-slot').dataset.slotIndex]) {
                 touchDraggedSlot = e.target.closest('.hotbar-slot');
                 touchDraggedSlot.style.opacity = '0.5';
             }
        }, {passive: false});

        inventoryGrid.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, {passive: false});

        inventoryGrid.addEventListener('touchend', (e) => {
            if (touchDraggedSlot) {
                touchDraggedSlot.style.opacity = '1';
                const touch = e.changedTouches[0];
                const elementUnder = document.elementFromPoint(touch.clientX, touch.clientY);
                const targetSlot = elementUnder ? elementUnder.closest('.hotbar-slot') : null;
                
                if (targetSlot) {
                    const fromIndex = parseInt(touchDraggedSlot.dataset.slotIndex);
                    const toIndex = parseInt(targetSlot.dataset.slotIndex);
                    
                    const temp = player.inventory[fromIndex];
                    player.inventory[fromIndex] = player.inventory[toIndex];
                    player.inventory[toIndex] = temp;
                    
                    updateInventoryScreen();
                }
                touchDraggedSlot = null;
            }
        });
    }
    </script>
</body>
</html>
